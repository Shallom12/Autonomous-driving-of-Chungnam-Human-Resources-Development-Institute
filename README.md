# Autonomous_drivingof_Chungnam_Human_Resources_Development
## ì•ˆë…•í•˜ì„¸ìš” ì£¼ì€ì´ì˜ ììœ¨ì£¼í–‰ì°¨ í”„ë¡œì íŠ¸ì— ì˜¤ì‹ ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤
### ë§Œë‚˜ì„œ ë°˜ê°‘ìŠµë‹ˆë‹¤
![ai-generated-8403514_1280](https://github.com/user-attachments/assets/48199f10-e6b1-4d9b-ac52-e5a8911eaa83)
```
print(hello autonomous driving)
sudo apt update
pip install matplotlib as plt
```
# ğŸ“˜ AI í•™ìŠµ ì •ë¦¬

## 1. About GitHub, Markdown, Colab
- [GitHub ì‚¬ìš©ë²•](github-ì‚¬ìš©ë²•)


## GitHub ì‚¬ìš©ë²•

### âœ… GitHub ê³„ì • ë§Œë“œëŠ” ìˆœì„œ (2025ë…„ ê¸°ì¤€)

1. **ì›¹ ë¸Œë¼ìš°ì € ì—´ê¸°**
   í¬ë¡¬(Chrome), ì—£ì§€(Edge), ì‚¬íŒŒë¦¬(Safari) ì¤‘ í¸í•œ ê±¸ ì‚¬ìš©í•˜ì„¸ìš”.

2. **GitHub ì›¹ì‚¬ì´íŠ¸ ì ‘ì†**
   ì£¼ì†Œì°½ì— ì•„ë˜ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ê³  Enter ëˆ„ë¥´ì„¸ìš”: https://github.com

3. **íšŒì›ê°€ì… ì‹œì‘í•˜ê¸°**
   í™”ë©´ ì˜¤ë¥¸ìª½ ìœ„ ë˜ëŠ” ì¤‘ê°„ì— ìˆëŠ” Sign up ë²„íŠ¼ í´ë¦­

4. **ì´ë©”ì¼ ì£¼ì†Œ ì…ë ¥**
   í‰ì†Œ ìì£¼ ì‚¬ìš©í•˜ëŠ” ì´ë©”ì¼ì„ ì…ë ¥

5. **ë¹„ë°€ë²ˆí˜¸ ë§Œë“¤ê¸°**
   ì˜ì–´ ëŒ€ë¬¸ì, ì†Œë¬¸ì, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ ì„ì–´ ì•ˆì „í•˜ê²Œ!
   ì˜ˆì‹œ: Git1234!hub

6. **ì‚¬ìš©ì ì´ë¦„(Username) ì •í•˜ê¸°**
   ë‚˜ë§Œì˜ ê³ ìœ í•œ ì´ë¦„ì„ ì§€ì–´ìš” (ë‹¤ë¥¸ ì‚¬ëŒì´ ì“°ê³  ìˆìœ¼ë©´ ë¶ˆê°€)
   - ì˜ˆì‹œ: jetsunmom, sungsookjang66 ë“±
   - ì˜ì–´, ìˆ«ì, í•˜ì´í”ˆ(-) ê°€ëŠ¥ (ë„ì–´ì“°ê¸° âŒ)

### âœ… Repository ë§Œë“¤ê¸° ìˆœì„œ

1. **GitHubì— ë¡œê·¸ì¸ í›„ New Repository í´ë¦­**
2. ![new](https://github.com/user-attachments/assets/3481a680-f677-403b-be8c-1fe59d5aa7cb)

3. **Repository ì´ë¦„ ì…ë ¥**
4. **Public/Private ì„ íƒ**
5. **README.md íŒŒì¼ ìƒì„± ì²´í¬**
6. **Create repository ë²„íŠ¼ í´ë¦­**
   
![create_repository](https://github.com/user-attachments/assets/8c2eb16b-8dfc-465a-88cd-d35770d12df0)-----

# GitHub ë§ˆí¬ë‹¤ìš´ ê°€ì´ë“œ: ì´ˆë³´ìë¥¼ ìœ„í•œ ì‹œì‘ (2025ë…„ ìµœì‹ )

ì•ˆë…•í•˜ì„¸ìš”\! ì´ ë¬¸ì„œëŠ” GitHubì—ì„œ í”„ë¡œì íŠ¸ ë¬¸ì„œë¥¼ íš¨ê³¼ì ìœ¼ë¡œ ë§Œë“¤ê³  ì†Œí†µí•˜ëŠ” ë° í•„ìˆ˜ì ì¸ **ë§ˆí¬ë‹¤ìš´(Markdown)** ì‚¬ìš©ë²•ì„ ì•ˆë‚´í•©ë‹ˆë‹¤. ë§ˆí¬ë‹¤ìš´ì€ ê°„ë‹¨í•œ ë¬¸ë²•ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì•„ë¦„ë‹µê²Œ ê¾¸ë°€ ìˆ˜ ìˆëŠ” ê°•ë ¥í•œ ë„êµ¬ì…ë‹ˆë‹¤. íŠ¹íˆ GitHubì˜ `README.md` íŒŒì¼ì„ ì‘ì„±í•˜ëŠ” ë° ê°€ì¥ ë§ì´ í™œìš©ë©ë‹ˆë‹¤.

ì´ ê°€ì´ë“œë¥¼ í†µí•´ ì—¬ëŸ¬ë¶„ì˜ í”„ë¡œì íŠ¸ì— ìƒëª…ì„ ë¶ˆì–´ë„£ê³ , ë°©ë¬¸ìì—ê²Œ ëª…í™•í•˜ê³  ë§¤ë ¥ì ì¸ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆë„ë¡ ë•ê² ìŠµë‹ˆë‹¤.

-----

## ğŸš€ 1. ë¹ ë¥¸ ì‹œì‘: ê¸°ë³¸ ë¬¸ë²• ìš”ì•½

| ë¬¸ë²•                   | ì˜ˆì‹œ                                    | ë¯¸ë¦¬ë³´ê¸°                      |
| :--------------------- | :-------------------------------------- | :---------------------------- |
| **ì œëª©** | `# ì œëª©`, `## ì†Œì œëª©`                   | \# ì œëª©, \#\# ì†Œì œëª©             |
| **í…ìŠ¤íŠ¸ ê°•ì¡°** | `**êµµê²Œ**`, `*ê¸°ìš¸ì„ê¼´*`              | **êµµê²Œ**, *ê¸°ìš¸ì„ê¼´* |
| **ëª©ë¡ (ìˆœì„œ ì—†ìŒ)** | `* í•­ëª©`, `- í•­ëª©`                      | \* í•­ëª©                        |
| **ëª©ë¡ (ìˆœì„œ ìˆìŒ)** | `1. í•­ëª©`                               | 1. í•­ëª©                       |
| **ì¸ë¼ì¸ ì½”ë“œ** | `` `ì½”ë“œ` ``                            | `ì½”ë“œ`                        |
| **ì½”ë“œ ë¸”ë¡** | ` ```python ... ``` `           | (ì•„ë˜ ì˜ˆì‹œ ì°¸ê³ )              |
| **ë§í¬** | `[í…ìŠ¤íŠ¸](URL)`                         | [í…ìŠ¤íŠ¸](https://github.com) |
| **ì´ë¯¸ì§€** | `![ì„¤ëª…](URL)`                          | (ì•„ë˜ ì˜ˆì‹œ ì°¸ê³ )              |
| **ì¸ìš©ë¬¸** | `> ì¸ìš©ë¬¸`                              | \> ì¸ìš©ë¬¸                      |
| **êµ¬ë¶„ì„ ** | `---`                                   | ---                           |
| **í‘œ** | `| í—¤ë” | ...`                           | (ì•„ë˜ ì˜ˆì‹œ ì°¸ê³ )              |
| **ì²´í¬ë¦¬ìŠ¤íŠ¸ (GFM)** | `- [ ] ë¯¸ì™„ë£Œ`, `- [x] ì™„ë£Œ`           | - [ ] ë¯¸ì™„ë£Œ, - [x] ì™„ë£Œ      |
| **ì´ëª¨ì§€ (GFM)** | `:sparkles:`                            | âœ¨                            |

-----

## ğŸŒŸ 2. ìì„¸íˆ ì•Œì•„ë³´ê¸°: í•µì‹¬ ë§ˆí¬ë‹¤ìš´ ë¬¸ë²•

### 2.1. ì œëª© (Headings): ë¬¸ì„œì˜ ë¼ˆëŒ€ ì„¸ìš°ê¸°

`#` ê¸°í˜¸ì˜ ê°œìˆ˜ë¡œ ì œëª©ì˜ í¬ê¸°ë¥¼ ì¡°ì ˆí•©ë‹ˆë‹¤. HTMLì˜ `<h1>`ë¶€í„° `<h6>`ì™€ ìœ ì‚¬í•©ë‹ˆë‹¤.

```markdown
# í”„ë¡œì íŠ¸ ì´ë¦„ (ê°€ì¥ í° ì œëª©)
## ì£¼ìš” ì„¹ì…˜ (ì˜ˆ: ê°œìš”, ì„¤ì¹˜ ë°©ë²•)
### ì„¸ë¶€ ë‚´ìš© (ì˜ˆ: ì „ì œ ì¡°ê±´, ì‚¬ìš©ë²•)
#### ë” ê¹Šì€ ë‚´ìš©
```

### 2.2. í…ìŠ¤íŠ¸ ê¾¸ë¯¸ê¸° (Text Formatting): ë‚´ìš© ê°•ì¡°í•˜ê¸°

íŠ¹ì • ë‹¨ì–´ë‚˜ êµ¬ì ˆì„ ì‹œê°ì ìœ¼ë¡œ ê°•ì¡°í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì…ë‹ˆë‹¤.

```markdown
**ì´ í…ìŠ¤íŠ¸ëŠ” êµµê²Œ í‘œì‹œë©ë‹ˆë‹¤.**
*ì´ í…ìŠ¤íŠ¸ëŠ” ê¸°ìš¸ì„ê¼´ë¡œ í‘œì‹œë©ë‹ˆë‹¤.*
***ì´ í…ìŠ¤íŠ¸ëŠ” êµµê³  ê¸°ìš¸ì„ê¼´ì…ë‹ˆë‹¤.***
~~ì´ í…ìŠ¤íŠ¸ëŠ” ì·¨ì†Œì„ ì´ ìˆìŠµë‹ˆë‹¤.~~
```

### 2.3. ëª©ë¡ (Lists): ì •ë³´ ì²´ê³„í™”í•˜ê¸°

  * **ìˆœì„œ ì—†ëŠ” ëª©ë¡ (Unordered List):** `*`, `-`, `+` ì¤‘ í•˜ë‚˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

    ```markdown
    * ì²« ë²ˆì§¸ í•­ëª©
      * í•˜ìœ„ í•­ëª© 1
      * í•˜ìœ„ í•­ëª© 2
    - ë‘ ë²ˆì§¸ í•­ëª©
    ```

  * **ìˆœì„œ ìˆëŠ” ëª©ë¡ (Ordered List):** ìˆ«ìì™€ ë§ˆì¹¨í‘œ(`.`)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

    ```markdown
    1. ì²« ë²ˆì§¸ ë‹¨ê³„
    2. ë‘ ë²ˆì§¸ ë‹¨ê³„
       1. ì„¸ë¶€ ë‹¨ê³„ 1
       2. ì„¸ë¶€ ë‹¨ê³„ 2
    ```

### 2.4. ì½”ë“œ (Code): ì½”ë“œ ìŠ¤ë‹ˆí« ê³µìœ í•˜ê¸°

  * **ì¸ë¼ì¸ ì½”ë“œ:** ì§§ì€ ì½”ë“œ ì¡°ê°ì€ `` ` `` (ë°±í‹±)ìœ¼ë¡œ ê°ìŒ‰ë‹ˆë‹¤.

    ```markdown
    `git clone` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì €ì¥ì†Œë¥¼ ë³µì œí•©ë‹ˆë‹¤.
    ```

  * **ì½”ë“œ ë¸”ë¡:** ì—¬ëŸ¬ ì¤„ì˜ ì½”ë“œëŠ” ë°±í‹± 3ê°œ(\`\`\`)ë¡œ ì‹œì‘í•˜ê³  ëëƒ…ë‹ˆë‹¤. ì–¸ì–´ ì´ë¦„ì„ ì§€ì •í•˜ë©´ ì‹ íƒìŠ¤ í•˜ì´ë¼ì´íŒ…ì´ ì ìš©ë˜ì–´ ê°€ë…ì„±ì´ ë§¤ìš° ë†’ì•„ì§‘ë‹ˆë‹¤.

    ````markdown
    ```python
    # Python ì˜ˆì œ ì½”ë“œ
    def hello_world():
        print("Hello, GitHub Markdown!")

    hello_world()
    ````

### 2.5. ë§í¬ (Links): ê´€ë ¨ ìë£Œ ì—°ê²°í•˜ê¸°

`[ë§í¬ í…ìŠ¤íŠ¸](ë§í¬_URL)` í˜•ì‹ìœ¼ë¡œ ì™¸ë¶€ ì›¹ì‚¬ì´íŠ¸ë‚˜ ì €ì¥ì†Œ ë‚´ì˜ ë‹¤ë¥¸ íŒŒì¼ë¡œ ì—°ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

````markdown
[ê³µì‹ GitHub ì›¹ì‚¬ì´íŠ¸](https://github.com)
[í”„ë¡œì íŠ¸ ê¸°ì—¬ ê°€ì´ë“œ](./CONTRIBUTING.md)  ```

### 2.6. ì´ë¯¸ì§€ (Images): ì‹œê° ìë£Œ ì²¨ë¶€í•˜ê¸°

`![ì´ë¯¸ì§€ ì„¤ëª…](ì´ë¯¸ì§€_URL)` í˜•ì‹ìœ¼ë¡œ ì´ë¯¸ì§€ë¥¼ ì‚½ì…í•©ë‹ˆë‹¤.

```markdown
![ì˜ˆì‹œ ì´ë¯¸ì§€](https://via.placeholder.com/150/0000FF/FFFFFF?text=Placeholder)
````

### 2.7. ì¸ìš©ë¬¸ (Blockquotes): ì¤‘ìš”í•œ ë‚´ìš© ê°•ì¡°í•˜ê¸°

`>` ê¸°í˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ í…ìŠ¤íŠ¸ë¥¼ ì¸ìš©ë¬¸ í˜•ì‹ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.

```markdown
> "ì½”ë“œëŠ” ì˜ˆìˆ ê³¼ ê°™ë‹¤." - í”„ë¡œê·¸ë˜ë° ê²©ì–¸
>> ì¤‘ì²©ëœ ì¸ìš©ë¬¸ë„ ê°€ëŠ¥í•©ë‹ˆë‹¤.
```

### 2.8. êµ¬ë¶„ì„  (Horizontal Rules): ì„¹ì…˜ ë¶„ë¦¬í•˜ê¸°

`---`, `***`, `___` ì¤‘ 3ê°œ ì´ìƒì„ ì‚¬ìš©í•˜ì—¬ ê°€ë¡œ êµ¬ë¶„ì„ ì„ ë§Œë“­ë‹ˆë‹¤.

```markdown
ì²« ë²ˆì§¸ ì„¹ì…˜ì˜ ë‚´ìš©.

---

ë‘ ë²ˆì§¸ ì„¹ì…˜ì˜ ë‚´ìš©.
```

### 2.9. í‘œ (Tables): ë°ì´í„° ì •ë ¬í•˜ê¸°

`|` (íŒŒì´í”„)ì™€ `-` (í•˜ì´í”ˆ)ë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ í‘œ í˜•íƒœë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.

```markdown
| í—¤ë” 1 | í—¤ë” 2   | í—¤ë” 3      |
| :----- | :------: | --------: |
| ì™¼ìª½ ì •ë ¬ | ì¤‘ì•™ ì •ë ¬ | ì˜¤ë¥¸ìª½ ì •ë ¬ |
| ë°ì´í„° A | ë°ì´í„° B | ë°ì´í„° C    |
```
-----

## âœ¨ 3. GitHub Flavored Markdown (GFM): GitHubë§Œì˜ íŠ¹ë³„í•œ ê¸°ëŠ¥

GitHubëŠ” í‘œì¤€ ë§ˆí¬ë‹¤ìš´ ì™¸ì— ê°œë°œìì—ê²Œ ìœ ìš©í•œ ëª‡ ê°€ì§€ í™•ì¥ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

### 3.1. ì²´í¬ë¦¬ìŠ¤íŠ¸ (Task Lists)

ì´ìŠˆë‚˜ PR(Pull Request) ì„¤ëª…ì—ì„œ ì‘ì—… ì§„í–‰ ìƒíƒœë¥¼ í‘œì‹œí•  ë•Œ ìœ ìš©í•©ë‹ˆë‹¤.

```markdown
- [ ] ë¬¸ì„œ ì—…ë°ì´íŠ¸ ê³„íš
- [x] ë²„ê·¸ ìˆ˜ì • ì™„ë£Œ
- [ ] í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±
```

### 3.2. ì´ëª¨ì§€ (Emojis)

`:` ê¸°í˜¸ì™€ ì´ëª¨ì§€ ì´ë¦„(Cheatsheet ì°¸ê³ )ì„ ì‚¬ìš©í•˜ì—¬ ê·€ì—¬ìš´ ì´ëª¨í‹°ì½˜ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

```markdown
ì´ í”„ë¡œì íŠ¸ëŠ” :heart: ì‚¬ë‘ìœ¼ë¡œ ë§Œë“¤ì–´ì¡ŒìŠµë‹ˆë‹¤!
```

### 3.3. ì‚¬ìš©ì/ì´ìŠˆ/ì»¤ë°‹ ì°¸ì¡° (Mentions, Issues, Commits)

  * **ì‚¬ìš©ì ë©˜ì…˜:** `@ì‚¬ìš©ìëª…` ì„ í†µí•´ íŠ¹ì • GitHub ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ì„ ë³´ëƒ…ë‹ˆë‹¤. ì˜ˆ: `@octocat`
  * **ì´ìŠˆ/PR ì°¸ì¡°:** `#ì´ìŠˆë²ˆí˜¸` ë¥¼ í†µí•´ í•´ë‹¹ ì €ì¥ì†Œì˜ ì´ìŠˆë‚˜ PRì„ ì°¸ì¡°í•©ë‹ˆë‹¤. ì˜ˆ: `#123` (ì´ìŠˆ 123ë²ˆ)
  * **ì»¤ë°‹ ì°¸ì¡°:** ì»¤ë°‹ í•´ì‹œ(Commit Hash)ì˜ ì²˜ìŒ ëª‡ ê¸€ìë¥¼ ì…ë ¥í•˜ì—¬ íŠ¹ì • ì»¤ë°‹ì— ë§í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆ: `a1b2c3d`

-----

## ğŸ’¡ 4. ë§ˆí¬ë‹¤ìš´ ì‘ì„± íŒ & ëª¨ë²” ì‚¬ë¡€

  * **ê°„ê²°í•˜ê²Œ:** í•„ìš”í•œ ì •ë³´ë§Œ ëª…í™•í•˜ê²Œ ì „ë‹¬í•˜ì„¸ìš”.
  * **ì¼ê´€ì„±:** ì œëª©, ëª©ë¡, ì½”ë“œ ìŠ¤íƒ€ì¼ ë“± ë¬¸ì„œ ì „ì²´ì—ì„œ ì¼ê´€ëœ í¬ë§·ì„ ìœ ì§€í•˜ì„¸ìš”.
  * **ë¯¸ë¦¬ë³´ê¸°:** GitHubì—ì„œ íŒŒì¼ì„ ì €ì¥í•˜ê¸° ì „ì— í•­ìƒ ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ ì–´ë–»ê²Œ ë³´ì¼ì§€ í™•ì¸í•˜ì„¸ìš”.
  * **ëª©ì°¨ ì‚¬ìš©:** ê¸´ README íŒŒì¼ì—ëŠ” `[ì œëª©](#ì œëª©-id)` í˜•íƒœì˜ ë‚´ë¶€ ë§í¬ë¥¼ í™œìš©í•˜ì—¬ ëª©ì°¨ë¥¼ ë§Œë“¤ì–´ì£¼ë©´ í¸ë¦¬í•©ë‹ˆë‹¤. (ì˜ˆ: `[ë¹ ë¥¸ ì‹œì‘](#-1-ë¹ ë¥¸-ì‹œì‘-ê¸°ë³¸-ë¬¸ë²•-ìš”ì•½)`)
  * **ì´ëª¨ì§€ í™œìš©:** ì ì ˆí•œ ì´ëª¨ì§€ëŠ” ë¬¸ì„œì˜ ë¶„ìœ„ê¸°ë¥¼ ë¶€ë“œëŸ½ê²Œ í•˜ê³  ì‹œì„ ì„ ëŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ê³¼ë„í•œ ì‚¬ìš©ì€ ì§€ì–‘)
  * **`.md` í™•ì¥ì:** ë§ˆí¬ë‹¤ìš´ íŒŒì¼ì€ í•­ìƒ `.md` ë˜ëŠ” `.markdown` í™•ì¥ìë¥¼ ì‚¬ìš©í•´ì•¼ GitHubì—ì„œ ì œëŒ€ë¡œ ë Œë”ë§ë©ë‹ˆë‹¤.

-----

## ğŸ“š 5. ë” ì•Œì•„ë³´ê¸° (ì¶”ê°€ ìë£Œ)

  * **GitHub Markdown Cheatsheet:** [https://guides.github.com/features/mastering-markdown/](https://guides.github.com/features/mastering-markdown/)
  * **Markdown Guide:** [https://www.markdownguide.org/basic-syntax/](https://www.markdownguide.org/basic-syntax/)

-----

- [Colab ê¸°ì´ˆ](#colab-ê¸°ì´ˆ)

## Colab ê¸°ì´ˆ    

(ì—¬ê¸°ì— Colab ë‚´ìš© ì‘ì„±)
![colab1](https://github.com/user-attachments/assets/13ad41ca-8f7c-40fe-b6d6-a47800bea3a9)ì£¼ì–´ì§„ ì´ë¯¸ì§€ë“¤ì„ ë°”íƒ•ìœ¼ë¡œ Google Colaboratory (Colab) ê¸°ì´ˆ ë‚´ìš©ì„ ì¢€ ë” ìƒì„¸í•˜ê³  ì‹œê°ì ìœ¼ë¡œ ëª…í™•í•˜ê²Œ ì¬êµ¬ì„±í•˜ì—¬ GitHub ë§ˆí¬ë‹¤ìš´ì— ì í•©í•œ í˜•íƒœë¡œ ë§Œë“¤ì–´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤. ì´ì „ ë‚´ìš©ê³¼ ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ì€ í†µí•©í•˜ê³ , ìƒˆë¡œìš´ ì •ë³´ë¥¼ ì¶”ê°€í•˜ê² ìŠµë‹ˆë‹¤.

-----

# ğŸš€ Google Colaboratory (Colab) ì‹œì‘í•˜ê¸°: ì‹¤ì „ ê°€ì´ë“œ

ì•ˆë…•í•˜ì„¸ìš”\! ì´ ê°€ì´ë“œëŠ” **Google Colaboratory (Colab)** ë¥¼ ì‚¬ìš©í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ë°©ë²•ë“¤ì„ ì•ˆë‚´í•©ë‹ˆë‹¤. Colabì€ Googleì—ì„œ ë¬´ë£Œë¡œ ì œê³µí•˜ëŠ” í´ë¼ìš°ë“œ ê¸°ë°˜ì˜ Jupyter ë…¸íŠ¸ë¶ í™˜ê²½ìœ¼ë¡œ, ì›¹ ë¸Œë¼ìš°ì €ë§Œ ìˆë‹¤ë©´ ëˆ„êµ¬ë‚˜ ì‰½ê²Œ íŒŒì´ì¬ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê³ , ì‹¬ì§€ì–´ GPU/TPU ê°™ì€ ê³ ì„±ëŠ¥ í•˜ë“œì›¨ì–´ ê°€ì†ê¸°ê¹Œì§€ í™œìš©í•˜ì—¬ ë¨¸ì‹ ëŸ¬ë‹ ë° ë°ì´í„° ê³¼í•™ í”„ë¡œì íŠ¸ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**í•µì‹¬ ì´ì :**

  * **ë¬´ë£Œ:** GPU/TPU ìì›ê¹Œì§€ ë¬´ë£Œë¡œ ì œê³µë©ë‹ˆë‹¤.
  * **ì„¤ì • ë¶ˆí•„ìš”:** ì›¹ ë¸Œë¼ìš°ì €ë§Œ ìˆìœ¼ë©´ ë°”ë¡œ ì½”ë”©ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  * **í˜‘ì—…:** Google ë¬¸ì„œì²˜ëŸ¼ ì—¬ëŸ¬ ëª…ì´ ë™ì‹œì— ì‘ì—…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  * **GitHub ì—°ë™:** `.ipynb` íŒŒì¼ì„ GitHubì— ì˜¬ë¦¬ë©´ ì½”ë“œì™€ ì‹¤í–‰ ê²°ê³¼ë¥¼ í•¨ê»˜ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

-----

## ğŸ 1ë‹¨ê³„: Colab ì‹œì‘í•˜ê¸° & ìƒˆ ë…¸íŠ¸ë¶ ë§Œë“¤ê¸°

Colabì€ Google ê³„ì •ë§Œ ìˆë‹¤ë©´ ì‰½ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 1.1 Colab ì ‘ì† ë°©ë²•

1.  **ê°€ì¥ ì‰¬ìš´ ë°©ë²•:** ì•„ë˜ ì£¼ì†Œë¡œ ì ‘ì†í•©ë‹ˆë‹¤.
    [https://colab.research.google.com](https://colab.research.google.com)

2.  **ë˜ëŠ” Google ë“œë¼ì´ë¸Œì—ì„œ:**

    1.  [Google ë“œë¼ì´ë¸Œ](https://drive.google.com) ì— ì ‘ì†í•©ë‹ˆë‹¤.
    2.  ì™¼ìª½ ìƒë‹¨ì˜ `[+ ìƒˆë¡œ ë§Œë“¤ê¸°]`ë¥¼ í´ë¦­í•©ë‹ˆë‹¤.
    3.  `ë”ë³´ê¸° > Google Colaboratory`ë¥¼ í´ë¦­í•©ë‹ˆë‹¤.

    <!-- end list -->

      * ğŸ“Œ **íŒ:** ì²˜ìŒ ì‹¤í–‰ ì‹œ "Google Colabì„ ì„¤ì¹˜í•˜ì‹œê² ìŠµë‹ˆê¹Œ?"ë¼ëŠ” ë©”ì‹œì§€ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì„¤ì¹˜í•˜ë©´ ë‹¤ìŒë¶€í„°ëŠ” ìë™ìœ¼ë¡œ ì—°ê²°ë©ë‹ˆë‹¤.

### 1.2 ìƒˆ ë…¸íŠ¸ë¶ ë§Œë“¤ê¸°

Colabì€ `.ipynb` í™•ì¥ìë¥¼ ê°€ì§„ ì£¼í”¼í„°(Jupyter) ë…¸íŠ¸ë¶ íŒŒì¼ë¡œ ì‘ì—…í•©ë‹ˆë‹¤.

  * **ì‹œì‘ ì‹œ:** `ìƒˆ ë…¸íŠ¸` ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ìƒˆë¡œìš´ ë…¸íŠ¸ë¶ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     \* **ê¸°ë³¸ ì´ë¦„:** ë³´í†µ `Untitled0.ipynb`ì²˜ëŸ¼ ìë™ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤.
  * **ì´ë¦„ ë³€ê²½:** ë…¸íŠ¸ë¶ ìƒë‹¨ì˜ íŒŒì¼ëª…ì„ í´ë¦­í•˜ì—¬ ì›í•˜ëŠ” ì´ë¦„ìœ¼ë¡œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì˜ˆ: `My_First_Colab_Notebook.ipynb`)

-----

## ğŸ§± 2ë‹¨ê³„: Colab ë…¸íŠ¸ë¶ êµ¬ì„± ì´í•´í•˜ê¸°

Colab ë…¸íŠ¸ë¶ì€ ë‹¤ìŒì˜ í•µì‹¬ ìš”ì†Œë“¤ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.

| êµ¬ì„±     | ì„¤ëª…                                 |
| :------- | :----------------------------------- |
| â–¶ ì½”ë“œ ì…€ | íŒŒì´ì¬ ì½”ë“œë¥¼ ì‘ì„±í•˜ê³  ì‹¤í–‰í•˜ëŠ” ê³µê°„ |
| ğŸ“œ í…ìŠ¤íŠ¸ ì…€ | ë§ˆí¬ë‹¤ìš´(ê¸€ ì„¤ëª…)ì„ ì‘ì„±í•˜ëŠ” ê³µê°„    |
| ğŸ”„ ëŸ°íƒ€ì„ | ì½”ë“œê°€ ì‹¤í–‰ë˜ëŠ” í™˜ê²½ (CPU, GPU ì„ íƒ) |

-----

## ğŸ› ï¸ 3ë‹¨ê³„: ì…€(Cell) ì¶”ê°€ / ì‚­ì œ / ì‹¤í–‰

Colab ì‘ì—…ì˜ ê¸°ë³¸ì€ 'ì…€' ë‹¨ìœ„ë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

| ì‘ì—…          | ë°©ë²•                                       |
| :------------ | :----------------------------------------- |
| **ì½”ë“œ ì…€ ì¶”ê°€** | ìƒë‹¨ ë©”ë‰´: `+ ì½”ë“œ` ë²„íŠ¼ í´ë¦­                      |
| **í…ìŠ¤íŠ¸ ì…€ ì¶”ê°€** | ìƒë‹¨ ë©”ë‰´: `+ í…ìŠ¤íŠ¸` ë²„íŠ¼ í´ë¦­                    |
| **ì…€ ì‚­ì œ** | ì…€ ì™¼ìª½ ì  3ê°œ(`â‹®`) í´ë¦­ â†’ `íœ´ì§€í†µ` ì•„ì´ì½˜ í´ë¦­ |
| **ì…€ ì‹¤í–‰** | `Shift + Enter` ë˜ëŠ” ì…€ ì¢Œì¸¡ì˜ `â–¶` ì•„ì´ì½˜ í´ë¦­ |

-----

## âš™ï¸ 4ë‹¨ê³„: ì‹¤í–‰ í™˜ê²½ ì„¤ì • (GPU ì‚¬ìš© ë“±)

ë¨¸ì‹ ëŸ¬ë‹ì´ë‚˜ ë”¥ëŸ¬ë‹ ì‘ì—… ì‹œì—ëŠ” ê°•ë ¥í•œ í•˜ë“œì›¨ì–´ ê°€ì†ê¸°(GPU/TPU)ë¥¼ í™œìš©í•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

1.  **ëŸ°íƒ€ì„ ìœ í˜• ë³€ê²½:** ìƒë‹¨ ë©”ë‰´ `[ëŸ°íƒ€ì„]` â†’ `[ëŸ°íƒ€ì„ ìœ í˜• ë³€ê²½]`ì„ í´ë¦­í•©ë‹ˆë‹¤.
     2.  **í•˜ë“œì›¨ì–´ ê°€ì†ê¸° ì„ íƒ:** `í•˜ë“œì›¨ì–´ ê°€ì†ê¸°` ë“œë¡­ë‹¤ìš´ì—ì„œ `GPU` ë˜ëŠ” `TPU`ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.

      * **ì €ì¥ í›„ ë‹¤ì‹œ ì‹¤í–‰í•˜ë©´ AI í•™ìŠµë„ ê°€ëŠ¥í•©ë‹ˆë‹¤\!**

### 4.1. ìš©ë„ë³„ ì¶”ì²œ ì„¤ì •

| í•˜ê³  ì‹¶ì€ ì¼              | ì¶”ì²œ í•˜ë“œì›¨ì–´ ê°€ì†ê¸° | ì´ìœ                                           |
| :------------------------ | :------------------- | :-------------------------------------------- |
| **ë‹¨ìˆœí•œ íŒŒì´ì¬ ì—°ìŠµ** | âœ… **CPU (ê¸°ë³¸ê°’)** | ë¹ ë¥´ê³  ì„¤ì • ì—†ì´ ì‚¬ìš© ê°€ëŠ¥                    |
| **ë”¥ëŸ¬ë‹, AI ëª¨ë¸ ì‹¤í–‰** | âœ… **T4 GPU** ë˜ëŠ” **A100 GPU** | AI ì—°ì‚°ì— ìµœì í™”, GPUëŠ” í•„ìˆ˜                |
| **ê³ ì† ì´ë¯¸ì§€ ì²˜ë¦¬, í›ˆë ¨** | âœ… **L4 GPU** | ì˜ìƒ ì²˜ë¦¬ë‚˜ ëŒ€ê·œëª¨ í›ˆë ¨ì— ì í•©                |
| **TPUë¥¼ ì‚¬ìš©í•œ ë”¥ëŸ¬ë‹** | â— **TPU (v2-8 ë“±)** | ë¹ ë¥´ì§€ë§Œ ì„¤ì • ë³µì¡ (ì´ˆë³´ì ë¹„ì¶”ì²œ, íŠ¹ìˆ˜ ê²½ìš°) |

**ì „ë¬¸ê°€ íŒ:** ì²˜ìŒì—ëŠ” `CPU`ë¡œ ì‹œì‘í•˜ê³ , ë”¥ëŸ¬ë‹ ëª¨ë¸ í›ˆë ¨ ë“± ì»´í“¨íŒ… ìì›ì´ ë§ì´ í•„ìš”í•  ë•Œë§Œ `GPU`ë¡œ ë³€ê²½í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

-----

## ğŸ“ 5ë‹¨ê³„: êµ¬ê¸€ ë“œë¼ì´ë¸Œ ì—°ë™ & íŒŒì¼ ê´€ë¦¬

Colab ë…¸íŠ¸ë¶ì€ Google Driveì— ìë™ ì €ì¥ë˜ë©°, Driveì˜ íŒŒì¼ë“¤ì„ Colabì—ì„œ ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  * Colabì€ ìë™ ì €ì¥ë©ë‹ˆë‹¤.
  * **íŒŒì¼ \> ì‚¬ë³¸ ì €ì¥ \> ë‚´ ë“œë¼ì´ë¸Œì— ì €ì¥**ì„ í†µí•´ ëª…ì‹œì ìœ¼ë¡œ ì‚¬ë³¸ì„ ì €ì¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  * ë“œë¼ì´ë¸Œì˜ `.ipynb` íŒŒì¼ì„ ë”ë¸”í´ë¦­í•˜ë©´ ë‹¤ì‹œ Colabìœ¼ë¡œ ì—´ë¦½ë‹ˆë‹¤.

### 5.1. Google Drive ë§ˆìš´íŠ¸ (ì—°ë™)

Colab ë…¸íŠ¸ë¶ì—ì„œ Google Driveì— ìˆëŠ” ë°ì´í„°ë‚˜ ë‹¤ë¥¸ ë…¸íŠ¸ë¶ì— ì ‘ê·¼í•˜ë ¤ë©´ Driveë¥¼ ë§ˆìš´íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤.

```python
from google.colab import drive
drive.mount('/content/drive')
# ì„±ê³µì ìœ¼ë¡œ ë§ˆìš´íŠ¸ë˜ë©´ 'Mounted at /content/drive' ë©”ì‹œì§€ê°€ ì¶œë ¥ë©ë‹ˆë‹¤.
```

ì´ì œ `/content/drive/MyDrive/` ê²½ë¡œë¥¼ í†µí•´ Google Drive ë‚´ì˜ íŒŒì¼ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```python
# ì˜ˆì‹œ: Driveì— ìˆëŠ” CSV íŒŒì¼ ì½ê¸°
import pandas as pd
df = pd.read_csv('/content/drive/MyDrive/MyProject/data.csv')
print(df.head())
```

-----

## ğŸ¤ 6ë‹¨ê³„: í˜‘ì—… ë° GitHub ì—°ë™

Colabì€ í˜‘ì—…ì— ë§¤ìš° ê°•ë ¥í•˜ë©°, GitHubì™€ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ê·¸ ì‹œë„ˆì§€ê°€ ê·¹ëŒ€í™”ë©ë‹ˆë‹¤.

### 6.1. ë…¸íŠ¸ë¶ ê³µìœ  (Google Drive ë°©ì‹)

Google ë¬¸ì„œì²˜ëŸ¼ ì—¬ëŸ¬ ëª…ì´ ë™ì‹œì— Colab ë…¸íŠ¸ë¶ì„ í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

1.  ë…¸íŠ¸ë¶ ìš°ì¸¡ ìƒë‹¨ì˜ `ê³µìœ (Share)` ë²„íŠ¼ì„ í´ë¦­í•©ë‹ˆë‹¤.
2.  ê³µìœ  ì„¤ì •ì„ ë³€ê²½í•˜ì—¬ íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ì ‘ê·¼ ê¶Œí•œì„ ë¶€ì—¬í•˜ê±°ë‚˜, ë§í¬ë¥¼ ì•„ëŠ” ëª¨ë“  ì‚¬ëŒì´ ë³¼ ìˆ˜ ìˆë„ë¡ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### 6.2. GitHubì— Colab ë…¸íŠ¸ë¶ ì˜¬ë¦¬ê¸°

`.ipynb` íŒŒì¼ì€ GitHubì—ì„œ íŠ¹ë³„í•˜ê²Œ ë‹¤ë£¨ì–´ì§‘ë‹ˆë‹¤.

1.  ì‘ì„±í•œ Colab ë…¸íŠ¸ë¶(`.ipynb` íŒŒì¼)ì„ Google Driveì—ì„œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
2.  GitHub ì €ì¥ì†Œì— ì´ `.ipynb` íŒŒì¼ì„ ì—…ë¡œë“œí•©ë‹ˆë‹¤.
3.  GitHubì—ì„œ `.ipynb` íŒŒì¼ì„ í´ë¦­í•˜ë©´, ì½”ë“œëŠ” ë¬¼ë¡  **ì‹¤í–‰ ê²°ê³¼ì™€ ë§ˆí¬ë‹¤ìš´ ì„¤ëª…ê¹Œì§€ ì›¹ í˜ì´ì§€ì—ì„œ ë°”ë¡œ ë Œë”ë§ë˜ì–´ ë³´ì…ë‹ˆë‹¤\!**

**ì „ë¬¸ê°€ íŒ:** ì´ ê¸°ëŠ¥ì€ í”„ë¡œì íŠ¸ì˜ ë¶„ì„ ê³¼ì •, ì‹¤í—˜ ê²°ê³¼, ë°ì´í„° ì‹œê°í™” ë“±ì„ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šê³ ë„ ë‹¤ë¥¸ ì‚¬ëŒë“¤ì—ê²Œ ëª…í™•í•˜ê²Œ ë³´ì—¬ì¤„ ìˆ˜ ìˆì–´, í”„ë¡œì íŠ¸ ë¬¸ì„œí™”ì— ë§¤ìš° ê°•ë ¥í•©ë‹ˆë‹¤.

-----

## ğŸ’¡ 7. Colab ì‚¬ìš© íŒ & ëª¨ë²” ì‚¬ë¡€

  * **ë‹¨ì¶•í‚¤ í™œìš©:**
      * `Shift + Enter`: í˜„ì¬ ì…€ ì‹¤í–‰ ë° ë‹¤ìŒ ì…€ë¡œ ì´ë™
      * `Ctrl/Cmd + Enter`: í˜„ì¬ ì…€ ì‹¤í–‰
      * `Ctrl/Cmd + M A`: í˜„ì¬ ì…€ ìœ„ì— ì½”ë“œ ì…€ ì¶”ê°€
      * `Ctrl/Cmd + M B`: í˜„ì¬ ì…€ ì•„ë˜ì— ì½”ë“œ ì…€ ì¶”ê°€
  * **PIP ì„¤ì¹˜:** í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì—†ë‹¤ë©´ ì…€ì—ì„œ `!pip install ë¼ì´ë¸ŒëŸ¬ë¦¬_ì´ë¦„` ëª…ë ¹ì–´ë¡œ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  * **ì£¼ì„ê³¼ í…ìŠ¤íŠ¸ ì…€:** ì½”ë“œëŠ” `#`ìœ¼ë¡œ ì£¼ì„ì„ ë‹¬ê³ , í…ìŠ¤íŠ¸ ì…€ì„ í†µí•´ ì½”ë“œì˜ ëª©ì , ë°ì´í„° ì„¤ëª…, ê²°ê³¼ í•´ì„ ë“±ì„ ìì„¸íˆ ì‘ì„±í•˜ì—¬ ë…¸íŠ¸ë¶ì˜ ê°€ë…ì„±ì„ ë†’ì´ì„¸ìš”.
  * **ëŸ°íƒ€ì„ ì¬ì‹œì‘/ì—°ê²° í•´ì œ:** í•„ìš” ì‹œ `ëŸ°íƒ€ì„(Runtime)` ë©”ë‰´ì—ì„œ í™˜ê²½ì„ ì´ˆê¸°í™”í•˜ê±°ë‚˜ ì—°ê²°ì„ í•´ì œí•˜ì—¬ ë¦¬ì†ŒìŠ¤ë¥¼ ê´€ë¦¬í•˜ì„¸ìš”.

-----

## 2. About Python3
- [Python basic](./docs/python3.md)

## 3.  data structure / data sciencs

- [ë°ì´í„° êµ¬ì¡° ê°œìš”](./data_structures.md)
- [Pandas](./pandas.md)
- [Numpy](./numpy.md)
- [Matplotlib](./Matplotlib.md)

## 4. Machine Learning

- [Machine Learning Basic](./ml_basic.md)
- [ëª¨ë¸ í›ˆë ¨ ë° í‰ê°€](./ml_test.md)
- <img width="702" alt="Screenshot 2025-06-24 at 10 39 00" src="https://github.com/user-attachments/assets/347973e1-d7fe-407d-8d4f-8190260e8824" />


## 5. OpenCV

- [OpenCV Basic](./OpenCV_basic.md)
- [ì´ë¯¸ì§€ ì²˜ë¦¬](./image_test.md)

  
## 6. CNN(Convolution Neural Network
- [CNN_Basic](./CNN_basic.md)
- [CNN_ììœ¨ì£¼í–‰ ê´€ë ¨ ì½”ë“œ](./cnn_test.md)

## 7. Ultralytics
- [Ultralytics_Basic](./Ultralytics_basic.md)
- [YOLOv8](./YOLOv8_test.md)
- [YOLOv12](./YOLOv12_test.md)
  
## 8. TensorRT vs PyTorch 
- [PyTorch_Basic](./PyTorch_basic.md)
- [TensorRT](./TensorRT_test.md)
- [YOLOv12](./YOLOv12_test.md)

## 9. TAO Toolkit on RunPod
- [TAO_ì‚¬ìš©ë²•](.TAO_install.md)
- [TAO_Toolkit](.TAO_Toolkit.md)

## 10. ì¹¼ë§Œí•„í„°, CARLA, ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜
- [kalman](.kalman.md)
- [CARLA_simulator](.CARLA.md)

## 11. ADAS & (ADAS TensorRT vs PyTorch)
- [adas_basic](.adas_basic.md)
- [TensorRT vs PyTorch ë¹„êµ](.vs.md)
- 


# ğŸš— ììœ¨ì£¼í–‰ ê°œë°œ í•µì‹¬ ë³€ìˆ˜ ê°€ì´ë“œ

> ììœ¨ì£¼í–‰ ì‹œìŠ¤í…œ ê°œë°œì—ì„œ í•„ìˆ˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë³€ìˆ˜ë“¤ì„ ì¹´í…Œê³ ë¦¬ë³„ë¡œ ì •ë¦¬í•œ ì‹¤ë¬´ ê°€ì´ë“œì…ë‹ˆë‹¤.

## ğŸ“‹ ëª©ì°¨

- [ì°¨ëŸ‰ ìƒíƒœ ë³€ìˆ˜](#-ì°¨ëŸ‰-ìƒíƒœ-ë³€ìˆ˜-vehicle-state)
- [ì œì–´ ë³€ìˆ˜](#-ì œì–´-ë³€ìˆ˜-control-variables)
- [ê²½ë¡œ ê³„íš ë³€ìˆ˜](#-ê²½ë¡œ-ê³„íš-ë³€ìˆ˜-path-planning)
- [ì„¼ì„œ ë°ì´í„° ë³€ìˆ˜](#-ì„¼ì„œ-ë°ì´í„°-ë³€ìˆ˜-sensor-data)
- [ì•ˆì „ ë° ì¶©ëŒ íšŒí”¼ ë³€ìˆ˜](#-ì•ˆì „-ë°-ì¶©ëŒ-íšŒí”¼-ë³€ìˆ˜-safety--collision-avoidance)
- [ì£¼í–‰ ëª¨ë“œ ë³€ìˆ˜](#-ì£¼í–‰-ëª¨ë“œ-ë³€ìˆ˜-driving-modes)
- [í™˜ê²½ ë³€ìˆ˜](#-í™˜ê²½-ë³€ìˆ˜-environment)
- [ì‹œê°„ ê´€ë ¨ ë³€ìˆ˜](#-ì‹œê°„-ê´€ë ¨-ë³€ìˆ˜-time-related)
- [ì°¨ëŸ‰ ë¬¼ë¦¬ì  íŠ¹ì„± ë³€ìˆ˜](#-ì°¨ëŸ‰-ë¬¼ë¦¬ì -íŠ¹ì„±-ë³€ìˆ˜-vehicle-physical-properties)

---

## ğŸ“ ì°¨ëŸ‰ ìƒíƒœ ë³€ìˆ˜ (Vehicle State)

ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜, ë°©í–¥, ì†ë„ ë“± ê¸°ë³¸ì ì¸ ìƒíƒœ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ—ºï¸ ìœ„ì¹˜ ì •ë³´ (Position Information)

```python
# 3D ê³µê°„ì—ì„œì˜ ì°¨ëŸ‰ ìœ„ì¹˜
x, y, z = 0.0, 0.0, 0.0        # ì°¨ëŸ‰ì˜ 3D ì¢Œí‘œ (ë¯¸í„° ë‹¨ìœ„)

# ì°¨ëŸ‰ì˜ ë°©í–¥ ì •ë³´
heading = 0.0                   # ì°¨ëŸ‰ì˜ ë°©í–¥ê° (yaw) - ì¢Œìš° íšŒì „
pitch = 0.0                     # ì°¨ëŸ‰ì˜ ì•ë’¤ ê¸°ìš¸ê¸° (ìƒí•˜ ê°ë„)
roll = 0.0                      # ì°¨ëŸ‰ì˜ ì¢Œìš° ê¸°ìš¸ê¸° (ë¡¤ë§ ê°ë„)
```

### ğŸƒâ€â™‚ï¸ ì†ë„ ì •ë³´ (Velocity Information)

```python
# ì§ì„  ìš´ë™ ê´€ë ¨
velocity = 0.0                  # í˜„ì¬ ì†ë„ (km/h ë˜ëŠ” m/s)
acceleration = 0.0              # ê°€ì†ë„ (m/sÂ²)

# íšŒì „ ìš´ë™ ê´€ë ¨
angular_velocity = 0.0          # ê°ì†ë„ (rad/s) - íšŒì „ ì†ë„
```

---

## ğŸ® ì œì–´ ë³€ìˆ˜ (Control Variables)

ì°¨ëŸ‰ì˜ ì›€ì§ì„ì„ ì§ì ‘ ì œì–´í•˜ëŠ” ëª…ë ¹ê°’ë“¤ì„ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ”„ ì¡°í–¥ ì œì–´ (Steering Control)

```python
steering_angle = 0.0            # í˜„ì¬ ì¡°í–¥ê° (ë„ ë‹¨ìœ„)
max_steering_angle = 30.0       # ìµœëŒ€ ì¡°í–¥ê° ì œí•œ (ë¬¼ë¦¬ì  í•œê³„)

# ì¡°í–¥ ë°©í–¥ ì˜ˆì‹œ
# steering_angle > 0  : ìš°íšŒì „
# steering_angle = 0  : ì§ì§„
# steering_angle < 0  : ì¢ŒíšŒì „
```

### âš¡ ì†ë„ ì œì–´ (Speed Control)

```python
# ì•¡ì…€/ë¸Œë ˆì´í¬ ì œì–´ (0~1 ë²”ìœ„)
throttle = 0.0                  # ìŠ¤ë¡œí‹€ ê°œë„ (0: ì—†ìŒ, 1: ìµœëŒ€)
brake = 0.0                     # ë¸Œë ˆì´í¬ ê°•ë„ (0: ì—†ìŒ, 1: ìµœëŒ€)

# ì†ë„ ëª©í‘œê°’
target_speed = 30.0             # ëª©í‘œ ì†ë„ (km/h)
max_speed = 60.0                # ìµœëŒ€ í—ˆìš© ì†ë„ (ì•ˆì „ ì œí•œ)
```

---

## ğŸ—ºï¸ ê²½ë¡œ ê³„íš ë³€ìˆ˜ (Path Planning)

ì°¨ëŸ‰ì´ ëª©ì ì§€ê¹Œì§€ ì´ë™í•  ê²½ë¡œì™€ ê´€ë ¨ëœ ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ“ ì›¨ì´í¬ì¸íŠ¸ (Waypoints)

```python
# ê²½ë¡œ ê´€ë ¨ ë°ì´í„° êµ¬ì¡°
waypoints = []                  # ê²½ë¡œìƒì˜ ëª¨ë“  ì ë“¤
target_waypoint = None          # í˜„ì¬ ëª©í‘œë¡œ í•˜ëŠ” ì 
path = []                       # ê³„íšëœ ìƒì„¸ ê²½ë¡œ
route = []                      # ì „ì²´ ë£¨íŠ¸ (í° êµ¬ê°„ë“¤)

# ê±°ë¦¬ ê³„ì‚°
distance_to_target = 0.0        # í˜„ì¬ ëª©í‘œì ê¹Œì§€ì˜ ê±°ë¦¬
lookahead_distance = 10.0       # ì „ë°© ì£¼ì‹œ ê±°ë¦¬ (ê²½ë¡œ ì¶”ì¢…ìš©)
```

### ğŸŒ ì‹¤ì œ GPS ì¢Œí‘œ ì˜ˆì‹œ

```python
# ì„œìš¸/ê²½ê¸°ë„ ì§€ì—­ì˜ ì‹¤ì œ waypoints ì˜ˆì‹œ
waypoints = np.array([
    [127.123, 37.456],          # ì‹œì‘ì  (ê°•ë‚¨êµ¬ ê·¼ì²˜)
    [127.126, 37.456],          # ì•ˆì „ ì ‘ê·¼
    [127.130, 37.463],          # ì¥ì• ë¬¼1 ìœ„ë¡œ íšŒí”¼
    [127.134, 37.462],          # ì¥ì• ë¬¼2 ì•„ë˜ë¡œ íšŒí”¼
    [127.139, 37.468],          # ì¥ì• ë¬¼3 ìœ„ë¡œ íšŒí”¼
    [127.143, 37.474],          # ëª©ì ì§€ ì ‘ê·¼
    [127.145, 37.478]           # ìµœì¢… ëª©ì ì§€
])

# GPS ì¢Œí‘œ ë¶„í•´
start_position = waypoints[0]   # [127.123, 37.456] - ì‹œì‘ì 
current_lon = start_position[0] # 127.123 (ê²½ë„, longitude)
current_lat = start_position[1] # 37.456 (ìœ„ë„, latitude)
```

#### ğŸŒ GPS ì¢Œí‘œê³„ ì´í•´í•˜ê¸°

| ìš©ì–´ | ì˜ë¬¸ | ì˜ë¯¸ | ë°©í–¥ |
|------|------|------|------|
| **ê²½ë„** | longitude (lon) | ë™ì„œ ë°©í–¥ ìœ„ì¹˜ | ì„¸ë¡œì„  (ë™ê²½/ì„œê²½) |
| **ìœ„ë„** | latitude (lat) | ë‚¨ë¶ ë°©í–¥ ìœ„ì¹˜ | ê°€ë¡œì„  (ë¶ìœ„/ë‚¨ìœ„) |

> ğŸ’¡ **ì¢Œí‘œ í•´ì„**: `[127.123, 37.456]`ì€ ë™ê²½ 127.123ë„, ë¶ìœ„ 37.456ë„ë¥¼ ì˜ë¯¸í•˜ë©°, ì„œìš¸ ê°•ë‚¨êµ¬ ê·¼ì²˜ì˜ ì‹¤ì œ ìœ„ì¹˜ì…ë‹ˆë‹¤.

---

## ğŸ“¡ ì„¼ì„œ ë°ì´í„° ë³€ìˆ˜ (Sensor Data)

ë‹¤ì–‘í•œ ì„¼ì„œë¡œë¶€í„° ìˆ˜ì§‘ë˜ëŠ” ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ“· ì¹´ë©”ë¼ ë°ì´í„° (Camera Data)

```python
camera_data = None              # ì¹´ë©”ë¼ë¡œ ì´¬ì˜í•œ ì´ë¯¸ì§€ ë°ì´í„°
lane_lines = []                 # ê°ì§€ëœ ì°¨ì„  ì •ë³´ ë¦¬ìŠ¤íŠ¸
traffic_signs = []              # ì¸ì‹ëœ êµí†µ í‘œì§€íŒ ë¦¬ìŠ¤íŠ¸
traffic_lights = []             # ê°ì§€ëœ ì‹ í˜¸ë“± ì •ë³´

# ì˜ìƒ ì²˜ë¦¬ ê²°ê³¼
detected_objects = []           # ì¸ì‹ëœ ëª¨ë“  ê°ì²´ë“¤
pedestrians = []                # ë³´í–‰ì ì •ë³´
vehicles = []                   # ë‹¤ë¥¸ ì°¨ëŸ‰ ì •ë³´
```

### ğŸŒŠ ë¼ì´ë‹¤ ë°ì´í„° (LiDAR Data)

```python
lidar_points = []               # ë¼ì´ë‹¤ í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ë°ì´í„°
obstacles = []                  # ê°ì§€ëœ ì¥ì• ë¬¼ ë¦¬ìŠ¤íŠ¸
point_cloud_intensity = []      # ê° í¬ì¸íŠ¸ì˜ ë°˜ì‚¬ ê°•ë„

# 3D ê³µê°„ ì •ë³´
distance_map = []               # ê±°ë¦¬ ë§µ (2D ë°°ì—´)
height_map = []                 # ë†’ì´ ë§µ (ì§€í˜• ì •ë³´)
```

### ğŸ›°ï¸ GPS ë°ì´í„° (GPS Data)

```python
gps_lat, gps_lon = 0.0, 0.0    # í˜„ì¬ GPS ì¢Œí‘œ (ìœ„ë„, ê²½ë„)
gps_altitude = 0.0              # í•´ë°œ ê³ ë„ (ë¯¸í„°)
gps_accuracy = 0.0              # GPS ì •í™•ë„ (ë¯¸í„° ë‹¨ìœ„ ì˜¤ì°¨)
gps_timestamp = 0.0             # GPS ë°ì´í„° ìˆ˜ì‹  ì‹œê°„

# GPS ìƒíƒœ ì •ë³´
gps_fix_type = "3D"             # GPS ê³ ì • íƒ€ì… (2D/3D)
satellite_count = 8             # ì—°ê²°ëœ ìœ„ì„± ìˆ˜
```

---

## âš ï¸ ì•ˆì „ ë° ì¶©ëŒ íšŒí”¼ ë³€ìˆ˜ (Safety & Collision Avoidance)

ì°¨ëŸ‰ì˜ ì•ˆì „í•œ ì£¼í–‰ì„ ìœ„í•œ ì¶©ëŒ ê°ì§€ ë° íšŒí”¼ ê´€ë ¨ ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸš¨ ì¶©ëŒ ê°ì§€ (Collision Detection)

```python
collision_detected = False      # ì¶©ëŒ ìœ„í—˜ ê°ì§€ ì—¬ë¶€
safety_distance = 5.0           # ìµœì†Œ ì•ˆì „ ê±°ë¦¬ (ë¯¸í„°)
emergency_brake = False         # ë¹„ìƒ ë¸Œë ˆì´í¬ í™œì„±í™” ì—¬ë¶€

# ìœ„í—˜ë„ í‰ê°€
collision_risk_level = 0        # ì¶©ëŒ ìœ„í—˜ë„ (0: ì•ˆì „ ~ 10: ë§¤ìš° ìœ„í—˜)
time_to_collision = float('inf') # ì¶©ëŒê¹Œì§€ ì˜ˆìƒ ì‹œê°„ (ì´ˆ)
```

### ğŸš— ì£¼ë³€ ì°¨ëŸ‰ ì •ë³´ (Surrounding Vehicles)

```python
nearby_vehicles = []            # ì£¼ë³€ ì°¨ëŸ‰ë“¤ì˜ ì •ë³´ ë¦¬ìŠ¤íŠ¸
front_vehicle_distance = float('inf')  # ì•ì°¨ì™€ì˜ ê±°ë¦¬
rear_vehicle_distance = float('inf')   # ë’¤ì°¨ì™€ì˜ ê±°ë¦¬
left_vehicle_distance = float('inf')   # ì¢Œì¸¡ ì°¨ëŸ‰ê³¼ì˜ ê±°ë¦¬
right_vehicle_distance = float('inf')  # ìš°ì¸¡ ì°¨ëŸ‰ê³¼ì˜ ê±°ë¦¬

# ê° ì°¨ëŸ‰ì˜ ìƒì„¸ ì •ë³´ (ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì €ì¥)
vehicle_info = {
    'id': 1,                    # ì°¨ëŸ‰ ì‹ë³„ ID
    'position': [x, y],         # ì°¨ëŸ‰ ìœ„ì¹˜
    'velocity': 30.0,           # ì°¨ëŸ‰ ì†ë„
    'direction': 45.0,          # ì§„í–‰ ë°©í–¥
    'distance': 15.0            # ìš°ë¦¬ ì°¨ëŸ‰ê³¼ì˜ ê±°ë¦¬
}
```

---

## ğŸš¦ ì£¼í–‰ ëª¨ë“œ ë³€ìˆ˜ (Driving Modes)

ì°¨ëŸ‰ì˜ ë‹¤ì–‘í•œ ì£¼í–‰ ìƒíƒœì™€ ëª¨ë“œë¥¼ ê´€ë¦¬í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ¯ ì£¼í–‰ ìƒíƒœ (Driving State)

```python
# ì£¼í–‰ ëª¨ë“œ ì¢…ë¥˜
driving_mode = "NORMAL"         # í˜„ì¬ ì£¼í–‰ ëª¨ë“œ
# ê°€ëŠ¥í•œ ê°’: "NORMAL", "PARKING", "EMERGENCY", "MANUAL", "HIGHWAY"

autonomous_mode = True          # ììœ¨ì£¼í–‰ ëª¨ë“œ í™œì„±í™” ì—¬ë¶€
lane_change_mode = False        # ì°¨ì„  ë³€ê²½ ëª¨ë“œ ì—¬ë¶€
parking_mode = False            # ì£¼ì°¨ ëª¨ë“œ ì—¬ë¶€

# íŠ¹ìˆ˜ ìƒí™© ëª¨ë“œ
overtaking_mode = False         # ì¶”ì›” ëª¨ë“œ
reversing_mode = False          # í›„ì§„ ëª¨ë“œ
```

### ğŸ”„ ëª¨ë“œ ì „í™˜ (Mode Switching)

```python
mode_switch_request = None      # ëª¨ë“œ ì „í™˜ ìš”ì²­
mode_transition_time = 0.0      # ëª¨ë“œ ì „í™˜ì— ê±¸ë¦¬ëŠ” ì‹œê°„
previous_mode = "NORMAL"        # ì´ì „ ì£¼í–‰ ëª¨ë“œ (ë³µêµ¬ìš©)
```

---

## ğŸŒ¦ï¸ í™˜ê²½ ë³€ìˆ˜ (Environment)

ì£¼ë³€ í™˜ê²½ê³¼ ë„ë¡œ ìƒí™©ì— ê´€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### â˜€ï¸ ë‚ ì”¨ ë° ë„ë¡œ ìƒíƒœ (Weather & Road Conditions)

```python
# ë‚ ì”¨ ì •ë³´
weather_condition = "CLEAR"     # ë‚ ì”¨ ìƒíƒœ
# ê°€ëŠ¥í•œ ê°’: "CLEAR", "RAIN", "SNOW", "FOG", "CLOUDY"

road_condition = "DRY"          # ë„ë¡œ ìƒíƒœ
# ê°€ëŠ¥í•œ ê°’: "DRY", "WET", "ICY", "SNOWY"

visibility = 100.0              # ê°€ì‹œê±°ë¦¬ (ë¯¸í„°)
temperature = 20.0              # ì™¸ë¶€ ì˜¨ë„ (ì„­ì”¨)
humidity = 50.0                 # ìŠµë„ (%)
wind_speed = 5.0                # í’ì† (m/s)
```

### ğŸš¦ êµí†µ ìƒí™© (Traffic Conditions)

```python
# êµí†µ ì‹ í˜¸ ë° ê·œì¹™
traffic_light_state = "GREEN"   # í˜„ì¬ ì‹ í˜¸ë“± ìƒíƒœ
# ê°€ëŠ¥í•œ ê°’: "RED", "YELLOW", "GREEN", "UNKNOWN"

speed_limit = 50.0              # í˜„ì¬ êµ¬ê°„ ì œí•œ ì†ë„ (km/h)
road_type = "CITY"              # ë„ë¡œ íƒ€ì…
# ê°€ëŠ¥í•œ ê°’: "HIGHWAY", "CITY", "RESIDENTIAL", "PARKING_LOT"

traffic_density = "LIGHT"       # êµí†µ ë°€ë„
# ê°€ëŠ¥í•œ ê°’: "LIGHT", "MODERATE", "HEAVY", "JAM"
```

---

## â° ì‹œê°„ ê´€ë ¨ ë³€ìˆ˜ (Time Related)

ì‹œë®¬ë ˆì´ì…˜ì´ë‚˜ ì‹¤ì‹œê°„ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì‹œê°„ ê´€ë ¨ ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ• ì‹œê°„ ì •ë³´ (Time Information)

```python
current_time = 0.0              # í˜„ì¬ ì‹œê°„ (ìœ ë‹‰ìŠ¤ íƒ€ì„ìŠ¤íƒ¬í”„)
dt = 0.1                        # ì‹œê°„ ê°„ê²©/íƒ€ì„ìŠ¤í… (ì´ˆ)
simulation_time = 0.0           # ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ë¶€í„° ê²½ê³¼ ì‹œê°„

# í”„ë ˆì„ ê´€ë¦¬
frame_count = 0                 # ì²˜ë¦¬ëœ í”„ë ˆì„ ìˆ˜
fps = 30.0                      # ì´ˆë‹¹ í”„ë ˆì„ ìˆ˜
last_update_time = 0.0          # ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„

# ì„±ëŠ¥ ì¸¡ì •
processing_time = 0.0           # í•œ í”„ë ˆì„ ì²˜ë¦¬ ì‹œê°„
average_processing_time = 0.0   # í‰ê·  ì²˜ë¦¬ ì‹œê°„
```

---

## ğŸš— ì°¨ëŸ‰ ë¬¼ë¦¬ì  íŠ¹ì„± ë³€ìˆ˜ (Vehicle Physical Properties)

ì°¨ëŸ‰ì˜ ë¬¼ë¦¬ì  íŠ¹ì„±ê³¼ ì„±ëŠ¥ í•œê³„ë¥¼ ì •ì˜í•˜ëŠ” ë³€ìˆ˜ë“¤ì…ë‹ˆë‹¤.

### ğŸ“ ì°¨ëŸ‰ í¬ê¸° (Vehicle Dimensions)

```python
# ê¸°ë³¸ ì¹˜ìˆ˜ (ë¯¸í„° ë‹¨ìœ„)
vehicle_length = 4.5            # ì°¨ëŸ‰ ì „ì²´ ê¸¸ì´
vehicle_width = 1.8             # ì°¨ëŸ‰ ì „ì²´ ë„ˆë¹„
vehicle_height = 1.5            # ì°¨ëŸ‰ ë†’ì´
wheelbase = 2.7                 # ì•ë’¤ ë°”í€´ ì¶•ê°„ê±°ë¦¬

# ì•ˆì „ ë§ˆì§„ í¬í•¨ í¬ê¸°
safety_length = vehicle_length + 0.5    # ì•ˆì „ ì—¬ìœ ë¶„ í¬í•¨ ê¸¸ì´
safety_width = vehicle_width + 0.3      # ì•ˆì „ ì—¬ìœ ë¶„ í¬í•¨ ë„ˆë¹„
```

### âš¡ ì„±ëŠ¥ íŒŒë¼ë¯¸í„° (Performance Parameters)

```python
# ê°€ì†/ê°ì† ì„±ëŠ¥
max_acceleration = 3.0          # ìµœëŒ€ ê°€ì†ë„ (m/sÂ²)
max_deceleration = -8.0         # ìµœëŒ€ ê°ì†ë„ (m/sÂ²) - ìŒìˆ˜ê°’
emergency_deceleration = -10.0  # ë¹„ìƒ ì œë™ì‹œ ìµœëŒ€ ê°ì†ë„

# ì¡°í–¥ ì„±ëŠ¥
turning_radius = 5.0            # ìµœì†Œ íšŒì „ ë°˜ê²½ (ë¯¸í„°)
max_steering_rate = 15.0        # ìµœëŒ€ ì¡°í–¥ ë³€í™”ìœ¨ (ë„/ì´ˆ)

# ì—”ì§„ ì„±ëŠ¥
max_power = 200.0               # ìµœëŒ€ ì¶œë ¥ (kW)
max_torque = 400.0              # ìµœëŒ€ í† í¬ (Nm)
fuel_efficiency = 12.5          # ì—°ë¹„ (km/L)
```

---

## ğŸ’¾ ë³€ìˆ˜ ì´ˆê¸°í™” ì˜ˆì‹œ

ì‹¤ì œ í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë³€ìˆ˜ ì´ˆê¸°í™” ì½”ë“œì…ë‹ˆë‹¤.

```python
class AutonomousVehicle:
    def __init__(self):
        # ì°¨ëŸ‰ ìƒíƒœ ì´ˆê¸°í™”
        self.x, self.y, self.z = 0.0, 0.0, 0.0
        self.heading = 0.0
        self.velocity = 0.0
        
        # ì œì–´ ë³€ìˆ˜ ì´ˆê¸°í™”
        self.steering_angle = 0.0
        self.throttle = 0.0
        self.brake = 0.0
        
        # ì•ˆì „ ë³€ìˆ˜ ì´ˆê¸°í™”
        self.collision_detected = False
        self.safety_distance = 5.0
        
        # í™˜ê²½ ë³€ìˆ˜ ì´ˆê¸°í™”
        self.weather_condition = "CLEAR"
        self.speed_limit = 50.0
        
        # ë¬¼ë¦¬ì  íŠ¹ì„± ì„¤ì •
        self.vehicle_length = 4.5
        self.max_acceleration = 3.0
        
    def update_state(self, dt):
        """ì°¨ëŸ‰ ìƒíƒœë¥¼ ì‹œê°„ ê°„ê²© dtë§Œí¼ ì—…ë°ì´íŠ¸"""
        # ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œì§
        pass
```

---

## ğŸ”§ ì‹¤ì „ í™œìš© íŒ

### ë³€ìˆ˜ ëª…ëª… ê·œì¹™
- **ëª…í™•ì„±**: ë³€ìˆ˜ëª…ë§Œ ë´ë„ ìš©ë„ë¥¼ ì•Œ ìˆ˜ ìˆê²Œ ì‘ì„±
- **ì¼ê´€ì„±**: í”„ë¡œì íŠ¸ ì „ì²´ì—ì„œ ë™ì¼í•œ ëª…ëª… ê·œì¹™ ì‚¬ìš©
- **ë‹¨ìœ„ ëª…ì‹œ**: ì£¼ì„ì´ë‚˜ ë³€ìˆ˜ëª…ì— ë‹¨ìœ„ í¬í•¨ (`_m`, `_kmh` ë“±)

### ì´ˆê¸°ê°’ ì„¤ì •
- **ì•ˆì „ ìš°ì„ **: ì•ˆì „í•œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
- **ë¬¼ë¦¬ì  í•œê³„**: ì‹¤ì œ ì°¨ëŸ‰ì˜ ë¬¼ë¦¬ì  í•œê³„ë¥¼ ë°˜ì˜
- **ì„¼ì„œ ë¬´íš¨ê°’**: ì„¼ì„œ ë°ì´í„°ëŠ” ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ìœ¼ë¡œ ì´ˆê¸°í™”

### ë°ì´í„° íƒ€ì… ì„ íƒ
- **ì •ë°€ë„**: ìœ„ì¹˜ë‚˜ ì†ë„ëŠ” `float` ì‚¬ìš©
- **ë©”ëª¨ë¦¬ íš¨ìœ¨**: ë¶ˆí•„ìš”í•œ ì •ë°€ë„ëŠ” í”¼í•˜ê¸°
- **numpy ë°°ì—´**: ëŒ€ëŸ‰ì˜ ì„¼ì„œ ë°ì´í„°ëŠ” numpy í™œìš©

---

## ğŸ“š ì°¸ê³  ìë£Œ

- [ììœ¨ì£¼í–‰ ì°¨ëŸ‰ ì œì–´ ì‹œìŠ¤í…œ](https://en.wikipedia.org/wiki/Autonomous_car)
- [ROS (Robot Operating System)](https://www.ros.org/)
- [OpenCV ì»´í“¨í„° ë¹„ì „](https://opencv.org/)
- [PCL (Point Cloud Library)](https://pointclouds.org/)

---


# ğŸš— ììœ¨ì£¼í–‰ì„ ìœ„í•œ íŒŒì´ì¬ ëª…ë ¹ë¬¸ ì™„ë²½ ê°€ì´ë“œ

> ììœ¨ì£¼í–‰ ë¶„ì•¼ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” íŒŒì´ì¬ ëª…ë ¹ë¬¸ë“¤ì„ ì‹¤ì œ ì˜ˆì œì™€ í•¨ê»˜ í•™ìŠµí•´ë³´ì„¸ìš”!

## ğŸ“‹ ëª©ì°¨
- [1. List Comprehension](#1-list-comprehension)
- [2. Dictionary Comprehension](#2-dictionary-comprehension)
- [3. ì‹¤ì „ ê³¼ì œ ëª¨ìŒ](#3-ì‹¤ì „-ê³¼ì œ-ëª¨ìŒ)

---

## 1. List Comprehension

### ğŸ¯ ì„¼ì„œ ë°ì´í„° í•„í„°ë§ - ì•ˆì „ ê±°ë¦¬ ì´ìƒì˜ ì¥ì• ë¬¼ë§Œ ì¶”ì¶œ

```python
# ë¼ì´ë‹¤ ì„¼ì„œê°€ ê°ì§€í•œ ì¥ì• ë¬¼ê¹Œì§€ì˜ ê±°ë¦¬ ë°ì´í„° (ë‹¨ìœ„: ë¯¸í„°)
sensor_distances = [2.5, 8.3, 1.2, 15.7, 3.8, 0.9, 12.4, 6.1]

# 5ë¯¸í„° ì´ìƒ ë–¨ì–´ì§„ 'ì•ˆì „í•œ' ì¥ì• ë¬¼ë§Œ í•„í„°ë§
safe_distances = [dist for dist in sensor_distances if dist > 5.0]

print("ì•ˆì „ ê±°ë¦¬ ì´ìƒ ì¥ì• ë¬¼:", safe_distances)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì•ˆì „ ê±°ë¦¬ ì´ìƒ ì¥ì• ë¬¼: [8.3, 15.7, 12.4, 6.1]
```

**ğŸ’¡ í•´ì„¤:**
- `2.5, 1.2, 3.8, 0.9`ëŠ” 5ë¯¸í„° ë¯¸ë§Œì´ë¯€ë¡œ ìœ„í—˜ êµ¬ê°„ìœ¼ë¡œ ì œì™¸
- `8.3, 15.7, 12.4, 6.1`ì€ ì•ˆì „ ê±°ë¦¬ë¡œ ë¶„ë¥˜ë˜ì–´ í¬í•¨

---

### ğŸ§­ ì¢Œí‘œ ë³€í™˜ - ìƒëŒ€ ì¢Œí‘œë¥¼ ì ˆëŒ€ ì¢Œí‘œë¡œ ë³€í™˜

```python
# ì°¨ëŸ‰ì˜ í˜„ì¬ GPS ì¢Œí‘œ (ì ˆëŒ€ ì¢Œí‘œ)
vehicle_position = (10, 20)

# ì°¨ëŸ‰ ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œë¡œ ê°ì§€ëœ ì£¼ë³€ ë¬¼ì²´ë“¤
relative_points = [(1, 2), (-3, 4), (5, -1), (0, 3)]

# ìƒëŒ€ ì¢Œí‘œë¥¼ ì§€ë„ìƒ ì ˆëŒ€ ì¢Œí‘œë¡œ ë³€í™˜
absolute_points = [
    (x + vehicle_position[0], y + vehicle_position[1])
    for x, y in relative_points
]

print("ì ˆëŒ€ ì¢Œí‘œ:", absolute_points)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì ˆëŒ€ ì¢Œí‘œ: [(11, 22), (7, 24), (15, 19), (10, 23)]
```

**ğŸ’¡ í•´ì„¤:**
- `(1, 2)` â†’ `(11, 22)`: ì°¨ëŸ‰ ì•ìª½ ì˜¤ë¥¸ìª½ ë¬¼ì²´ì˜ ì§€ë„ìƒ ìœ„ì¹˜
- `(-3, 4)` â†’ `(7, 24)`: ì°¨ëŸ‰ ì™¼ìª½ ì•ì˜ ë¬¼ì²´ ìœ„ì¹˜
- ì„¼ì„œ ë°ì´í„°ë¥¼ ë‚´ë¹„ê²Œì´ì…˜ ì‹œìŠ¤í…œê³¼ ì—°ë™í•˜ê¸° ìœ„í•œ í•„ìˆ˜ ë³€í™˜

---

### ğŸš¦ ì†ë„ ì œí•œ ì ìš© - ê° êµ¬ê°„ë³„ ìµœëŒ€ ì†ë„ ì œí•œ

```python
# í˜„ì¬ ê° êµ¬ê°„ì—ì„œì˜ ì£¼í–‰ ì†ë„ (km/h)
current_speeds = [45, 75, 38, 82, 55, 95, 28]

# ê° êµ¬ê°„ì˜ ë²•ì • ì†ë„ ì œí•œ (km/h)
speed_limits = [50, 70, 40, 80, 60, 90, 30]

# í˜„ì¬ ì†ë„ì™€ ì œí•œ ì†ë„ ì¤‘ ì‘ì€ ê°’ì„ ì„ íƒ (ë²•ê·œ ì¤€ìˆ˜)
adjusted_speeds = [
    min(current, limit)
    for current, limit in zip(current_speeds, speed_limits)
]

print("ì†ë„ ì œí•œ ì ìš© í›„:", adjusted_speeds)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì†ë„ ì œí•œ ì ìš© í›„: [45, 70, 38, 80, 55, 90, 28]
```

**ğŸ’¡ í•´ì„¤:**
- `75 â†’ 70`: 70km/h ì œí•œêµ¬ê°„ì—ì„œ ê°ì† í•„ìš”
- `82 â†’ 80`: 80km/h ì œí•œêµ¬ê°„ì—ì„œ ê°ì† í•„ìš”
- `95 â†’ 90`: 90km/h ì œí•œêµ¬ê°„ì—ì„œ ê°ì† í•„ìš”

---

### ğŸ›£ï¸ ê²½ë¡œ í¬ì¸íŠ¸ ìƒì„± - ì‹œì‘ì ê³¼ ëì  ì‚¬ì´ì˜ ì¤‘ê°„ í¬ì¸íŠ¸ë“¤ ìƒì„±

```python
import math

# ì¶œë°œì§€ì™€ ëª©ì ì§€ ì¢Œí‘œ
start_point = (0, 0)    # ì§‘ ì£¼ì°¨ì¥
end_point = (10, 8)     # íšŒì‚¬ ì£¼ì°¨ì¥
num_points = 5          # 5ê°œì˜ ê²½ìœ ì§€ ìƒì„±

# ì„ í˜• ë³´ê°„ì„ ì´ìš©í•œ ê· ë“± ê°„ê²© ê²½ë¡œ í¬ì¸íŠ¸ ìƒì„±
path_points = [
    (
        start_point[0] + i * (end_point[0] - start_point[0]) / (num_points - 1),
        start_point[1] + i * (end_point[1] - start_point[1]) / (num_points - 1)
    )
    for i in range(num_points)
]

print("ê²½ë¡œ í¬ì¸íŠ¸ë“¤:", path_points)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ê²½ë¡œ í¬ì¸íŠ¸ë“¤: [(0.0, 0.0), (2.5, 2.0), (5.0, 4.0), (7.5, 6.0), (10.0, 8.0)]
```

**ğŸ’¡ í•´ì„¤:**
- ì§ì„  ê±°ë¦¬ë¥¼ 5ë“±ë¶„í•˜ì—¬ ë¶€ë“œëŸ¬ìš´ ì£¼í–‰ ê²½ë¡œ ìƒì„±
- ê¸‰ê²©í•œ ë°©í–¥ ì „í™˜ ëŒ€ì‹  ë‹¨ê³„ì  ì´ë™ìœ¼ë¡œ ìŠ¹ì°¨ê° í–¥ìƒ

---

### âš ï¸ ìœ„í—˜ ìƒí™© ê°ì§€ - ì¡°ê±´ë¶€ ë‹¤ì¤‘ í•„í„°ë§

```python
# ë‹¤ì–‘í•œ ì„¼ì„œì—ì„œ ìˆ˜ì§‘ëœ ë°ì´í„°
sensor_data = [
    {'type': 'lidar', 'distance': 3.2, 'angle': 45},    # ë¼ì´ë‹¤: ìš°ì¸¡ 45ë„, 3.2m
    {'type': 'camera', 'distance': 8.5, 'angle': 0},    # ì¹´ë©”ë¼: ì •ë©´, 8.5m
    {'type': 'radar', 'distance': 1.8, 'angle': -30},   # ë ˆì´ë”: ì¢Œì¸¡ 30ë„, 1.8m
    {'type': 'lidar', 'distance': 12.3, 'angle': 90}    # ë¼ì´ë‹¤: ìš°ì¸¡ 90ë„, 12.3m
]

# ìœ„í—˜ ì¡°ê±´: 5m ì´ë‚´ + ì „ë°© 60ë„ ë²”ìœ„ ë‚´
danger_sensors = [
    sensor for sensor in sensor_data
    if sensor['distance'] < 5.0 and abs(sensor['angle']) < 60
]

print("ìœ„í—˜ ê°ì§€ ì„¼ì„œ:", danger_sensors)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ìœ„í—˜ ê°ì§€ ì„¼ì„œ: [
    {'type': 'lidar', 'distance': 3.2, 'angle': 45}, 
    {'type': 'radar', 'distance': 1.8, 'angle': -30}
]
```

**ğŸ’¡ í•´ì„¤:**
- ì „ë°© 60ë„ ë²”ìœ„ ë‚´ì—ì„œ 5ë¯¸í„° ì´ë‚´ ì¥ì• ë¬¼ì„ ê°ì§€í•œ ì„¼ì„œë§Œ ì¶”ì¶œ
- ì¦‰ì‹œ ê°ì† ë˜ëŠ” íšŒí”¼ ê¸°ë™ì´ í•„ìš”í•œ ìœ„í—˜ ìƒí™© íŒë‹¨

---

## 2. Dictionary Comprehension

### ğŸ“Š ê¸°ë³¸ ë”•ì…”ë„ˆë¦¬ ìƒì„± - ì„¼ì„œë³„ ë°ì´í„° ê´€ë¦¬

```python
# 1. ì„¼ì„œ ë°ì´í„° ë”•ì…”ë„ˆë¦¬ ìƒì„±
sensor_data = {}
sensor_data['camera'] = 8.5    # ì¹´ë©”ë¼ ì„¼ì„œ: 8.5m
sensor_data['lidar'] = 12.3    # ë¼ì´ë‹¤ ì„¼ì„œ: 12.3m
sensor_data['radar'] = 15.7    # ë ˆì´ë” ì„¼ì„œ: 15.7m

print("ì„¼ì„œ ë°ì´í„°:", sensor_data)

# 2. ê²½ë¡œ ê³„íš - ëª©ì ì§€ë³„ ê±°ë¦¬ ì •ë³´
destinations = ['ì§‘', 'íšŒì‚¬', 'ë§ˆíŠ¸', 'ì£¼ìœ ì†Œ']
distances_km = [0, 15, 8, 12]

route_plan = {}
for i, dest in enumerate(destinations):
    route_plan[dest] = distances_km[i]

print("ëª©ì ì§€ë³„ ê±°ë¦¬:", route_plan)

# 3. ì°¨ëŸ‰ ìƒíƒœ ì²´í¬
vehicle_parts = ['ì—”ì§„', 'ë¸Œë ˆì´í¬', 'íƒ€ì´ì–´', 'ë°°í„°ë¦¬']
status_codes = ['ì •ìƒ', 'ì •ìƒ', 'êµì²´í•„ìš”', 'ì •ìƒ']

vehicle_status = {}
for i, part in enumerate(vehicle_parts):
    vehicle_status[part] = status_codes[i]

print("ì°¨ëŸ‰ ìƒíƒœ:", vehicle_status)
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì„¼ì„œ ë°ì´í„°: {'camera': 8.5, 'lidar': 12.3, 'radar': 15.7}
ëª©ì ì§€ë³„ ê±°ë¦¬: {'ì§‘': 0, 'íšŒì‚¬': 15, 'ë§ˆíŠ¸': 8, 'ì£¼ìœ ì†Œ': 12}
ì°¨ëŸ‰ ìƒíƒœ: {'ì—”ì§„': 'ì •ìƒ', 'ë¸Œë ˆì´í¬': 'ì •ìƒ', 'íƒ€ì´ì–´': 'êµì²´í•„ìš”', 'ë°°í„°ë¦¬': 'ì •ìƒ'}
```

---

### ğŸš¥ ì‹ í˜¸ë“± ì •ë³´ ê´€ë¦¬

```python
# êµì°¨ë¡œë³„ ì‹ í˜¸ë“± í˜„í™©
intersections = ['ì„œìš¸ì—­', 'ê°•ë‚¨ì—­', 'í™ëŒ€ì…êµ¬', 'ì ì‹¤ì—­']
light_colors = ['ë¹¨ê°•', 'ì´ˆë¡', 'ë…¸ë‘', 'ì´ˆë¡']
remaining_times = [25, 15, 3, 45]

# ì‹ í˜¸ë“± ì •ë³´ í†µí•© ê´€ë¦¬
traffic_lights = {}
for i, intersection in enumerate(intersections):
    traffic_lights[intersection] = {
        'color': light_colors[i],
        'time_left': remaining_times[i]
    }

print("êµì°¨ë¡œ ì‹ í˜¸ë“± í˜„í™©:")
for intersection, info in traffic_lights.items():
    print(f"  {intersection}: {info['color']} (ë‚¨ì€ì‹œê°„: {info['time_left']}ì´ˆ)")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
êµì°¨ë¡œ ì‹ í˜¸ë“± í˜„í™©:
  ì„œìš¸ì—­: ë¹¨ê°• (ë‚¨ì€ì‹œê°„: 25ì´ˆ)
  ê°•ë‚¨ì—­: ì´ˆë¡ (ë‚¨ì€ì‹œê°„: 15ì´ˆ)
  í™ëŒ€ì…êµ¬: ë…¸ë‘ (ë‚¨ì€ì‹œê°„: 3ì´ˆ)
  ì ì‹¤ì—­: ì´ˆë¡ (ë‚¨ì€ì‹œê°„: 45ì´ˆ)
```

---

### ğŸ…¿ï¸ ì£¼ì°¨ì¥ ì •ë³´ ì‹œìŠ¤í…œ

```python
# ì£¼ì°¨ì¥ êµ¬ì—­ë³„ í˜„í™©
parking_zones = ['Aêµ¬ì—­', 'Bêµ¬ì—­', 'Cêµ¬ì—­', 'Dêµ¬ì—­']
empty_spots = [5, 0, 12, 3]
total_spots = [20, 15, 25, 10]

# ì£¼ì°¨ì¥ ì •ë³´ ë”•ì…”ë„ˆë¦¬ ìƒì„±
parking_info = {}
for i, zone in enumerate(parking_zones):
    parking_info[zone] = {
        'empty': empty_spots[i],
        'total': total_spots[i],
        'occupancy_rate': round((total_spots[i] - empty_spots[i]) / total_spots[i] * 100, 1)
    }

print("ì£¼ì°¨ì¥ í˜„í™©:")
for zone, info in parking_info.items():
    print(f"  {zone}: {info['empty']}/{info['total']} ê°€ëŠ¥ (ì ìœ ìœ¨: {info['occupancy_rate']}%)")
    
# ë¹ˆ ì£¼ì°¨ê³µê°„ì´ ìˆëŠ” êµ¬ì—­ ì°¾ê¸°
available_zones = [zone for zone, info in parking_info.items() if info['empty'] > 0]
print(f"\nì£¼ì°¨ ê°€ëŠ¥í•œ êµ¬ì—­: {available_zones}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì£¼ì°¨ì¥ í˜„í™©:
  Aêµ¬ì—­: 5/20 ê°€ëŠ¥ (ì ìœ ìœ¨: 75.0%)
  Bêµ¬ì—­: 0/15 ê°€ëŠ¥ (ì ìœ ìœ¨: 100.0%)
  Cêµ¬ì—­: 12/25 ê°€ëŠ¥ (ì ìœ ìœ¨: 52.0%)
  Dêµ¬ì—­: 3/10 ê°€ëŠ¥ (ì ìœ ìœ¨: 70.0%)

ì£¼ì°¨ ê°€ëŠ¥í•œ êµ¬ì—­: ['Aêµ¬ì—­', 'Cêµ¬ì—­', 'Dêµ¬ì—­']
```

---

## 3. ì‹¤ì „ ê³¼ì œ ëª¨ìŒ

### ğŸš¦ ê³¼ì œ 1: ìŠ¤ë§ˆíŠ¸ ì‹ í˜¸ë“± íƒ€ì´ë° ìµœì í™”

```python
print("=== ìŠ¤ë§ˆíŠ¸ ì‹ í˜¸ë“± íƒ€ì´ë° ìµœì í™” ===")

# êµì°¨ë¡œë³„ ëŒ€ê¸° ì°¨ëŸ‰ ìˆ˜ì™€ ì‹ í˜¸ë“± í˜„í™©
intersections = ['ì„œìš¸ì—­ì•', 'ì‹œì²­ì•', 'ì¢…ë¡œ3ê°€', 'ì„ì§€ë¡œì…êµ¬']
traffic_signals = {
    'ì„œìš¸ì—­ì•': {'color': 'ë¹¨ê°•', 'time_left': 25, 'waiting': 12},
    'ì‹œì²­ì•': {'color': 'ì´ˆë¡', 'time_left': 15, 'waiting': 8},
    'ì¢…ë¡œ3ê°€': {'color': 'ë¹¨ê°•', 'time_left': 40, 'waiting': 15},
    'ì„ì§€ë¡œì…êµ¬': {'color': 'ë…¸ë‘', 'time_left': 3, 'waiting': 5}
}

print("í˜„ì¬ êµì°¨ë¡œ ìƒí™©:")
for intersection in intersections:
    signal = traffic_signals[intersection]
    status_emoji = "ğŸ”´" if signal['color'] == 'ë¹¨ê°•' else "ğŸŸ¢" if signal['color'] == 'ì´ˆë¡' else "ğŸŸ¡"
    print(f"  {status_emoji} {intersection}: {signal['color']} {signal['time_left']}ì´ˆ, ëŒ€ê¸°ì°¨ëŸ‰ {signal['waiting']}ëŒ€")

# ìš°ì„ ìˆœìœ„ êµì°¨ë¡œ ì„ ì • (ëŒ€ê¸°ì°¨ëŸ‰ 10ëŒ€ ì´ìƒ)
print("\nâš ï¸  ìš°ì„ ì²˜ë¦¬ í•„ìš” êµì°¨ë¡œ:")
priority_intersections = [
    intersection for intersection in intersections
    if traffic_signals[intersection]['waiting'] >= 10
]

for intersection in priority_intersections:
    waiting = traffic_signals[intersection]['waiting']
    print(f"  ğŸš¨ {intersection}: ëŒ€ê¸°ì°¨ëŸ‰ {waiting}ëŒ€ â†’ ì‹ í˜¸ ì¡°ì • í•„ìš”")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
=== ìŠ¤ë§ˆíŠ¸ ì‹ í˜¸ë“± íƒ€ì´ë° ìµœì í™” ===
í˜„ì¬ êµì°¨ë¡œ ìƒí™©:
  ğŸ”´ ì„œìš¸ì—­ì•: ë¹¨ê°• 25ì´ˆ, ëŒ€ê¸°ì°¨ëŸ‰ 12ëŒ€
  ğŸŸ¢ ì‹œì²­ì•: ì´ˆë¡ 15ì´ˆ, ëŒ€ê¸°ì°¨ëŸ‰ 8ëŒ€
  ğŸ”´ ì¢…ë¡œ3ê°€: ë¹¨ê°• 40ì´ˆ, ëŒ€ê¸°ì°¨ëŸ‰ 15ëŒ€
  ğŸŸ¡ ì„ì§€ë¡œì…êµ¬: ë…¸ë‘ 3ì´ˆ, ëŒ€ê¸°ì°¨ëŸ‰ 5ëŒ€

âš ï¸  ìš°ì„ ì²˜ë¦¬ í•„ìš” êµì°¨ë¡œ:
  ğŸš¨ ì„œìš¸ì—­ì•: ëŒ€ê¸°ì°¨ëŸ‰ 12ëŒ€ â†’ ì‹ í˜¸ ì¡°ì • í•„ìš”
  ğŸš¨ ì¢…ë¡œ3ê°€: ëŒ€ê¸°ì°¨ëŸ‰ 15ëŒ€ â†’ ì‹ í˜¸ ì¡°ì • í•„ìš”
```

---

### ğŸ…¿ï¸ ê³¼ì œ 2: ìë™ ë°œë ›íŒŒí‚¹ ì‹œìŠ¤í…œ

```python
print("=== ìë™ ë°œë ›íŒŒí‚¹ ì‹œìŠ¤í…œ ===")

# ì£¼ì°¨ê³µê°„ í¬ê¸°ë³„ í˜„í™©
parking_spaces = {
    'ì†Œí˜•ì „ìš©': {'total': 30, 'occupied': 15, 'size_limit': 'ì†Œí˜•'},
    'ì¼ë°˜ê³µê°„': {'total': 40, 'occupied': 28, 'size_limit': 'ì¤‘í˜•'},
    'ëŒ€í˜•ê³µê°„': {'total': 15, 'occupied': 8, 'size_limit': 'ëŒ€í˜•'},
    'SUVì „ìš©': {'total': 20, 'occupied': 12, 'size_limit': 'SUV'}
}

print("ì£¼ì°¨ê³µê°„ í˜„í™©:")
for space_type, space in parking_spaces.items():
    available = space['total'] - space['occupied']
    utilization = round(space['occupied'] / space['total'] * 100, 1)
    print(f"  {space_type}: {available}/{space['total']} ê°€ëŠ¥ ({space['size_limit']} ì „ìš©, ì´ìš©ë¥  {utilization}%)")

# ì‹ ê·œ ì°¨ëŸ‰ ì£¼ì°¨ ì‹œë®¬ë ˆì´ì…˜
new_vehicle = 'SUV'
print(f"\nğŸš— ì‹ ê·œ {new_vehicle} ì°¨ëŸ‰ ì£¼ì°¨ ìš”ì²­")

# ì í•©í•œ ì£¼ì°¨ê³µê°„ ì°¾ê¸°
suitable_spaces = []
for space_type, space in parking_spaces.items():
    available = space['total'] - space['occupied']
    if space['size_limit'] == new_vehicle and available > 0:
        suitable_spaces.append(space_type)

if suitable_spaces:
    selected_space = suitable_spaces[0]
    available = parking_spaces[selected_space]['total'] - parking_spaces[selected_space]['occupied']
    print(f"âœ… {selected_space}ì— ì£¼ì°¨ ê°€ëŠ¥ (ë‚¨ì€ ìë¦¬: {available}ê°œ)")
else:
    print("âŒ ì í•©í•œ ì£¼ì°¨ê³µê°„ì´ ì—†ìŠµë‹ˆë‹¤")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
=== ìë™ ë°œë ›íŒŒí‚¹ ì‹œìŠ¤í…œ ===
ì£¼ì°¨ê³µê°„ í˜„í™©:
  ì†Œí˜•ì „ìš©: 15/30 ê°€ëŠ¥ (ì†Œí˜• ì „ìš©, ì´ìš©ë¥  50.0%)
  ì¼ë°˜ê³µê°„: 12/40 ê°€ëŠ¥ (ì¤‘í˜• ì „ìš©, ì´ìš©ë¥  70.0%)
  ëŒ€í˜•ê³µê°„: 7/15 ê°€ëŠ¥ (ëŒ€í˜• ì „ìš©, ì´ìš©ë¥  53.3%)
  SUVì „ìš©: 8/20 ê°€ëŠ¥ (SUV ì „ìš©, ì´ìš©ë¥  60.0%)

ğŸš— ì‹ ê·œ SUV ì°¨ëŸ‰ ì£¼ì°¨ ìš”ì²­
âœ… SUVì „ìš©ì— ì£¼ì°¨ ê°€ëŠ¥ (ë‚¨ì€ ìë¦¬: 8ê°œ)
```

---

### ğŸš› ê³¼ì œ 3: ì°¨ëŸ‰ êµ°ì§‘ì£¼í–‰ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
print("=== ì°¨ëŸ‰ êµ°ì§‘ì£¼í–‰ ê´€ë¦¬ ì‹œìŠ¤í…œ ===")

# êµ°ì§‘ì£¼í–‰ ê·¸ë£¹ë³„ ìƒì„¸ ì •ë³´
convoy_info = {
    'ê·¸ë£¹A': {'vehicles': 3, 'leader_speed': 80, 'formation': 'ì¼ë ¬'},
    'ê·¸ë£¹B': {'vehicles': 5, 'leader_speed': 70, 'formation': 'ì‚¼ê°'},
    'ê·¸ë£¹C': {'vehicles': 2, 'leader_speed': 90, 'formation': 'ë³‘ë ¬'}
}

print("êµ°ì§‘ì£¼í–‰ í˜„í™©:")
for group, info in convoy_info.items():
    formation_emoji = "ğŸš—ğŸš—ğŸš—" if info['formation'] == 'ì¼ë ¬' else "ğŸš—ğŸš—\nğŸš—" if info['formation'] == 'ì‚¼ê°' else "ğŸš—ğŸš—"
    print(f"  {group}: {info['vehicles']}ëŒ€, ì†ë„ {info['leader_speed']}km/h, {info['formation']}ëŒ€í˜•")

# ì•ˆì „ ì†ë„ ê¶Œì¥ (5ëŒ€ ì´ìƒì´ë©´ ì†ë„ ì œí•œ)
print("\nğŸ“‹ ì•ˆì „ ê¶Œì¥ì‚¬í•­:")
for group, info in convoy_info.items():
    if info['vehicles'] >= 5:
        recommended_speed = 60
        print(f"  âš ï¸ {group}: ì°¨ëŸ‰ {info['vehicles']}ëŒ€ë¡œ ì¸í•´ {recommended_speed}km/h ì´í•˜ ê¶Œì¥")
    else:
        print(f"  âœ… {group}: í˜„ì¬ ì†ë„ {info['leader_speed']}km/h ì ì •")

# êµ°ì§‘ íš¨ìœ¨ì„± ë¶„ì„
print("\nğŸ“Š êµ°ì§‘ íš¨ìœ¨ì„± ë¶„ì„:")
for group, info in convoy_info.items():
    if info['vehicles'] >= 3:
        fuel_efficiency = round(15 + (info['vehicles'] * 2), 1)  # ì—°ë¹„ ê°œì„  íš¨ê³¼
        print(f"  {group}: ì—°ë¹„ {fuel_efficiency}% ê°œì„  íš¨ê³¼")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
=== ì°¨ëŸ‰ êµ°ì§‘ì£¼í–‰ ê´€ë¦¬ ì‹œìŠ¤í…œ ===
êµ°ì§‘ì£¼í–‰ í˜„í™©:
  ê·¸ë£¹A: 3ëŒ€, ì†ë„ 80km/h, ì¼ë ¬ëŒ€í˜•
  ê·¸ë£¹B: 5ëŒ€, ì†ë„ 70km/h, ì‚¼ê°ëŒ€í˜•
  ê·¸ë£¹C: 2ëŒ€, ì†ë„ 90km/h, ë³‘ë ¬ëŒ€í˜•

ğŸ“‹ ì•ˆì „ ê¶Œì¥ì‚¬í•­:
  âœ… ê·¸ë£¹A: í˜„ì¬ ì†ë„ 80km/h ì ì •
  âš ï¸ ê·¸ë£¹B: ì°¨ëŸ‰ 5ëŒ€ë¡œ ì¸í•´ 60km/h ì´í•˜ ê¶Œì¥
  âœ… ê·¸ë£¹C: í˜„ì¬ ì†ë„ 90km/h ì ì •

ğŸ“Š êµ°ì§‘ íš¨ìœ¨ì„± ë¶„ì„:
  ê·¸ë£¹A: ì—°ë¹„ 21.0% ê°œì„  íš¨ê³¼
  ê·¸ë£¹B: ì—°ë¹„ 25.0% ê°œì„  íš¨ê³¼
```

---

### ğŸ”‹ ê³¼ì œ 4: ì „ê¸°ì°¨ ì¶©ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ

```python
print("=== ì „ê¸°ì°¨ ì¶©ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ ===")

# ì „ê¸°ì°¨ ë°°í„°ë¦¬ í˜„í™©
ev_fleet = ['ì „ê¸°ì°¨A', 'ì „ê¸°ì°¨B', 'ì „ê¸°ì°¨C', 'ì „ê¸°ì°¨D', 'ì „ê¸°ì°¨E']
ev_status = {
    'ì „ê¸°ì°¨A': {'battery': 85, 'range': 340, 'charging': False},
    'ì „ê¸°ì°¨B': {'battery': 25, 'range': 100, 'charging': False},
    'ì „ê¸°ì°¨C': {'battery': 60, 'range': 240, 'charging': True},
    'ì „ê¸°ì°¨D': {'battery': 15, 'range': 60, 'charging': False},
    'ì „ê¸°ì°¨E': {'battery': 90, 'range': 360, 'charging': False}
}

print("ì „ê¸°ì°¨ ë°°í„°ë¦¬ í˜„í™©:")
for vehicle, status in ev_status.items():
    battery_emoji = "ğŸ”‹" if status['battery'] > 50 else "ğŸª«" if status['battery'] > 20 else "âš¡"
    charging_status = "ì¶©ì „ì¤‘" if status['charging'] else "ëŒ€ê¸°ì¤‘"
    print(f"  {battery_emoji} {vehicle}: {status['battery']}% ({status['range']}km) - {charging_status}")

# ê¸´ê¸‰ ì¶©ì „ í•„ìš” ì°¨ëŸ‰ (ë°°í„°ë¦¬ 30% ì´í•˜)
print("\nğŸš¨ ê¸´ê¸‰ ì¶©ì „ í•„ìš”:")
urgent_vehicles = [
    vehicle for vehicle, status in ev_status.items()
    if status['battery'] <= 30 and not status['charging']
]

for vehicle in urgent_vehicles:
    battery = ev_status[vehicle]['battery']
    range_left = ev_status[vehicle]['range']
    print(f"  âš¡ {vehicle}: {battery}% (ì£¼í–‰ê°€ëŠ¥ {range_left}km) - ì¦‰ì‹œ ì¶©ì „ í•„ìš”")

# ì¶©ì „ì†Œ ì˜ˆì•½ ì‹œìŠ¤í…œ
charging_stations = {
    'ê°•ë‚¨ì¶©ì „ì†Œ': {'slots': 5, 'reserved': 2, 'fast_charge': True},
    'ì„œì´ˆì¶©ì „ì†Œ': {'slots': 3, 'reserved': 1, 'fast_charge': False},
    'ì¢…ë¡œì¶©ì „ì†Œ': {'slots': 4, 'reserved': 4, 'fast_charge': True}
}

print("\nğŸ”Œ ì¶©ì „ì†Œ ì˜ˆì•½ í˜„í™©:")
for station, info in charging_stations.items():
    available = info['slots'] - info['reserved']
    charge_type = "ê¸‰ì†ì¶©ì „" if info['fast_charge'] else "ì™„ì†ì¶©ì „"
    availability_emoji = "ğŸŸ¢" if available > 0 else "ğŸ”´"
    print(f"  {availability_emoji} {station}: {available}/{info['slots']} ì´ìš©ê°€ëŠ¥ ({charge_type})")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
=== ì „ê¸°ì°¨ ì¶©ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ ===
ì „ê¸°ì°¨ ë°°í„°ë¦¬ í˜„í™©:
  ğŸ”‹ ì „ê¸°ì°¨A: 85% (340km) - ëŒ€ê¸°ì¤‘
  ğŸª« ì „ê¸°ì°¨B: 25% (100km) - ëŒ€ê¸°ì¤‘
  ğŸ”‹ ì „ê¸°ì°¨C: 60% (240km) - ì¶©ì „ì¤‘
  âš¡ ì „ê¸°ì°¨D: 15% (60km) - ëŒ€ê¸°ì¤‘
  ğŸ”‹ ì „ê¸°ì°¨E: 90% (360km) - ëŒ€ê¸°ì¤‘

ğŸš¨ ê¸´ê¸‰ ì¶©ì „ í•„ìš”:
  âš¡ ì „ê¸°ì°¨B: 25% (ì£¼í–‰ê°€ëŠ¥ 100km) - ì¦‰ì‹œ ì¶©ì „ í•„ìš”
  âš¡ ì „ê¸°ì°¨D: 15% (ì£¼í–‰ê°€ëŠ¥ 60km) - ì¦‰ì‹œ ì¶©ì „ í•„ìš”

ğŸ”Œ ì¶©ì „ì†Œ ì˜ˆì•½ í˜„í™©:
  ğŸŸ¢ ê°•ë‚¨ì¶©ì „ì†Œ: 3/5 ì´ìš©ê°€ëŠ¥ (ê¸‰ì†ì¶©ì „)
  ğŸŸ¢ ì„œì´ˆì¶©ì „ì†Œ: 2/3 ì´ìš©ê°€ëŠ¥ (ì™„ì†ì¶©ì „)
  ğŸ”´ ì¢…ë¡œì¶©ì „ì†Œ: 0/4 ì´ìš©ê°€ëŠ¥ (ê¸‰ì†ì¶©ì „)
```

---

### ğŸŒ§ï¸ ê³¼ì œ 5: ë„ë¡œ ìœ„í—˜ë„ í‰ê°€ ë° ê²½ê³  ì‹œìŠ¤í…œ

```python
print("=== ë„ë¡œ ìœ„í—˜ë„ í‰ê°€ ë° ê²½ê³  ì‹œìŠ¤í…œ ===")

# ë„ë¡œ êµ¬ê°„ë³„ ìœ„í—˜ ìš”ì†Œ
road_segments = ['êµ¬ê°„A', 'êµ¬ê°„B', 'êµ¬ê°„C', 'êµ¬ê°„D']
road_conditions = [
    {'rain': True, 'fog': False, 'construction': False, 'accident': False},
    {'rain': False, 'fog': True, 'construction': True, 'accident': False},
    {'rain': True, 'fog': False, 'construction': False, 'accident': True},
    {'rain': False, 'fog': False, 'construction': False, 'accident': False}
]

# ë„ë¡œë³„ ìœ„í—˜ë„ ê³„ì‚°
road_safety = {}
for i, segment in enumerate(road_segments):
    conditions = road_conditions[i]
    risk_score = 0
    
    # ìœ„í—˜ ìš”ì†Œë³„ ì ìˆ˜ ë¶€ì—¬
    if conditions['rain']:
        risk_score += 20    # ìš°ì²œì‹œ ë¯¸ë„ëŸ¼ ìœ„í—˜
    if conditions['fog']:
        risk_score += 30    # ì•ˆê°œë¡œ ì¸í•œ ì‹œì•¼ ë¶ˆëŸ‰
    if conditions['construction']:
        risk_score += 25    # ê³µì‚¬ë¡œ ì¸í•œ ì°¨ë¡œ ë³€ê²½
    if conditions['accident']:
        risk_score += 50    # ì‚¬ê³ ë¡œ ì¸í•œ ì •ì²´/ìœ„í—˜
    
    road_safety[segment] = {'risk_score': risk_score, 'conditions': conditions}

print("ë„ë¡œ êµ¬ê°„ë³„ ìœ„í—˜ë„ ë¶„ì„:")
for segment in road_segments:
    safety = road_safety[segment]
    risk = safety['risk_score']
    conditions = safety['conditions']
    
    # ìœ„í—˜ë„ ë ˆë²¨ ë¶„ë¥˜
    if risk >= 50:
        level = "ë§¤ìš°ìœ„í—˜"
        level_emoji = "ğŸ”´"
    elif risk >= 30:
        level = "ìœ„í—˜"
        level_emoji = "ğŸŸ "
    elif risk >= 15:
        level = "ì£¼ì˜"
        level_emoji = "ğŸŸ¡"
    else:
        level = "ì•ˆì „"
        level_emoji = "ğŸŸ¢"
    
    print(f"  {level_emoji} {segment}: {risk}ì  ({level})")
    
    # ìœ„í—˜ ìš”ì†Œ ìƒì„¸ í‘œì‹œ
    warnings = []
    if conditions['rain']:
        warnings.append("ìš°ì²œ ğŸŒ§ï¸")
    if conditions['fog']:
        warnings.append("ì•ˆê°œ ğŸŒ«ï¸")
    if conditions['construction']:
        warnings.append("ê³µì‚¬ì¤‘ ğŸš§")
    if conditions['accident']:
        warnings.append("ì‚¬ê³ ë°œìƒ ğŸš¨")
    
    if warnings:
        print(f"    â”” ìœ„í—˜ìš”ì†Œ: {', '.join(warnings)}")

# ìš°íšŒ ê²½ë¡œ ê¶Œì¥
print("\nğŸ“ ê²½ë¡œ ê¶Œì¥ì‚¬í•­:")
safe_routes = [segment for segment, info in road_safety.items() if info['risk_score'] < 30]
dangerous_routes = [segment for segment, info in road_safety.items() if info['risk_score'] >= 50]

if safe_routes:
    print(f"  âœ… ì•ˆì „ ê²½ë¡œ: {', '.join(safe_routes)}")
if dangerous_routes:
    print(f"  âš ï¸ ìš°íšŒ ê¶Œì¥: {', '.join(dangerous_routes)}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
=== ë„ë¡œ ìœ„í—˜ë„ í‰ê°€ ë° ê²½ê³  ì‹œìŠ¤í…œ ===
ë„ë¡œ êµ¬ê°„ë³„ ìœ„í—˜ë„ ë¶„ì„:
  ğŸŸ¡ êµ¬ê°„A: 20ì  (ì£¼ì˜)
    â”” ìœ„í—˜ìš”ì†Œ: ìš°ì²œ ğŸŒ§ï¸
  ğŸ”´ êµ¬ê°„B: 55ì  (ë§¤ìš°ìœ„í—˜)
    â”” ìœ„í—˜ìš”ì†Œ: ì•ˆê°œ ğŸŒ«ï¸, ê³µì‚¬ì¤‘ ğŸš§
  ğŸ”´ êµ¬ê°„C: 70ì  (ë§¤ìš°ìœ„í—˜)
    â”” ìœ„í—˜ìš”ì†Œ: ìš°ì²œ ğŸŒ§ï¸


# ìë™ì°¨ ììœ¨ì£¼í–‰ ì‹œìŠ¤í…œ ê¸°ì¤€ì  ê°€ì´ë“œ

## ê°œìš”
ììœ¨ì£¼í–‰ ìë™ì°¨ ê°œë°œ ì‹œ ë‹¤ì–‘í•œ ì‹œìŠ¤í…œê³¼ ì„¼ì„œë“¤ì´ ì‚¬ìš©í•˜ëŠ” ê¸°ì¤€ì (Reference Points)ë“¤ì„ ì •ë¦¬í•œ ì¢…í•© ê°€ì´ë“œì…ë‹ˆë‹¤. ê° ê¸°ì¤€ì ì€ íŠ¹ì • ìƒí™©ê³¼ ëª©ì ì— ë”°ë¼ ì„ íƒë˜ë©°, ì •í™•í•œ ìœ„ì¹˜ ê³„ì‚°ê³¼ ì•ˆì „í•œ ì£¼í–‰ì„ ìœ„í•´ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤.

## ëª©ì°¨
1. [ì„¼ì„œ ìœ„ì¹˜ ê¸°ì¤€ì ](#1-ì„¼ì„œ-ìœ„ì¹˜-ê¸°ì¤€ì )
2. [ì•ˆì „ì„± ê¸°ì¤€ì ](#2-ì•ˆì „ì„±-ê¸°ì¤€ì )
3. [ì¡°í–¥ ê´€ë ¨ ê¸°ì¤€ì ](#3-ì¡°í–¥-ê´€ë ¨-ê¸°ì¤€ì )
4. [ì£¼ì°¨/ì •ë°€ ì œì–´ ê¸°ì¤€ì ](#4-ì£¼ì°¨ì •ë°€-ì œì–´-ê¸°ì¤€ì )
5. [ë™ì  ê¸°ì¤€ì ](#5-ë™ì -ê¸°ì¤€ì -ìƒí™©ë³„)
6. [ì¢Œí‘œê³„ë³„ ê¸°ì¤€ì ](#6-ì¢Œí‘œê³„ë³„-ê¸°ì¤€ì )
7. [ì œì–´ ì‹œìŠ¤í…œë³„ ê³ ë ¤ì‚¬í•­](#7-ì œì–´-ì‹œìŠ¤í…œë³„-ê³ ë ¤ì‚¬í•­)
8. [ë„ë¡œ ë° êµí†µ í™˜ê²½ ê¸°ì¤€ì ](#8-ë„ë¡œ-ë°-êµí†µ-í™˜ê²½-ê¸°ì¤€ì )
9. [ë²•ê·œ ë° ê·œì • ê¸°ì¤€ì ](#9-ë²•ê·œ-ë°-ê·œì •-ê¸°ì¤€ì )
10. [ë¬¼ë¦¬í•™ì /ì—­í•™ì  ê¸°ì¤€ì ](#10-ë¬¼ë¦¬í•™ì ì—­í•™ì -ê¸°ì¤€ì )
11. [í†µì‹  ë° V2X ê¸°ì¤€ì ](#11-í†µì‹ -ë°-v2x-ê¸°ì¤€ì )
12. [ì˜ˆì¸¡ ë° ë¯¸ë˜ ìœ„ì¹˜ ê¸°ì¤€ì ](#12-ì˜ˆì¸¡-ë°-ë¯¸ë˜-ìœ„ì¹˜-ê¸°ì¤€ì )
13. [ë‹¤ì¤‘ ì°¨ëŸ‰ ì‹œìŠ¤í…œ ê¸°ì¤€ì ](#13-ë‹¤ì¤‘-ì°¨ëŸ‰-ì‹œìŠ¤í…œ-ê¸°ì¤€ì )
14. [í™˜ê²½ ì¸ì‹ ê¸°ì¤€ì ](#14-í™˜ê²½-ì¸ì‹-ê¸°ì¤€ì )
15. [ë³´í—˜/ì‚¬ê³  ì¡°ì‚¬ ê¸°ì¤€ì ](#15-ë³´í—˜ì‚¬ê³ -ì¡°ì‚¬-ê¸°ì¤€ì )
16. [ì„±ëŠ¥ ìµœì í™” ê¸°ì¤€ì ](#16-ì„±ëŠ¥-ìµœì í™”-ê¸°ì¤€ì )
17. [ìŠ¹ê° ì•ˆì „/í¸ì˜ ê¸°ì¤€ì ](#17-ìŠ¹ê°-ì•ˆì „í¸ì˜-ê¸°ì¤€ì )

---

## 1. ì„¼ì„œ ìœ„ì¹˜ ê¸°ì¤€ì 

ììœ¨ì£¼í–‰ ì°¨ëŸ‰ì˜ ë‹¤ì–‘í•œ ì„¼ì„œë“¤ì€ ê°ê° ìµœì ì˜ ìœ„ì¹˜ì— ì„¤ì¹˜ë˜ë©°, ì´ë“¤ì˜ ìœ„ì¹˜ ì •ë³´ëŠ” ì„¼ì„œ ìœµí•©ê³¼ ì •í™•í•œ í™˜ê²½ ì¸ì‹ì„ ìœ„í•´ í•„ìˆ˜ì ì…ë‹ˆë‹¤.

```python
# ì°¨ëŸ‰ ê¸°ë³¸ ìœ„ì¹˜ (x, y, z) - í›„ì¶• ì¤‘ì‹¬ ê¸°ì¤€
vehicle_base_position = (0, 0, 0)

class SensorPositions:
    def __init__(self, vehicle_x, vehicle_y, vehicle_z):
        self.base_x = vehicle_x
        self.base_y = vehicle_y  
        self.base_z = vehicle_z
        
        # ë¼ì´ë‹¤: ì°¨ëŸ‰ ì§€ë¶• ìœ„ ì¤‘ì•™ì— ì„¤ì¹˜ (360ë„ ìŠ¤ìº”ì„ ìœ„í•´)
        self.lidar_position = (
            self.base_x + 0.5,  # ì°¨ëŸ‰ ì¤‘ì‹¬ì—ì„œ ì•ìª½ìœ¼ë¡œ 0.5m
            self.base_y,        # ì°¨ëŸ‰ ì¤‘ì‹¬ì„ 
            self.base_z + 1.2   # ì§€ë©´ì—ì„œ 1.2m ë†’ì´
        )
        
        # ì¹´ë©”ë¼: ì•ë²”í¼ ê·¼ì²˜ (ì „ë°© ì‹œì•¼ í™•ë³´)
        self.camera_position = (
            self.base_x + 2.0,  # ì°¨ëŸ‰ ì•ìª½ ë
            self.base_y,        # ì°¨ëŸ‰ ì¤‘ì‹¬ì„ 
            self.base_z + 0.8   # ì ì ˆí•œ ì‹œì•¼ê° í™•ë³´ ë†’ì´
        )
        
        # ë ˆì´ë”: ì „ë©´ í•˜ë‹¨ (ê·¼ê±°ë¦¬ ì¥ì• ë¬¼ ê°ì§€)
        self.radar_position = (
            self.base_x + 2.1,  # ì¹´ë©”ë¼ë³´ë‹¤ ì•½ê°„ ì•ìª½
            self.base_y,        # ì°¨ëŸ‰ ì¤‘ì‹¬ì„ 
            self.base_z + 0.3   # ë‚®ì€ ë†’ì´ì—ì„œ ë„ë¡œë©´ ìŠ¤ìº”
        )
        
        # GPS ì•ˆí…Œë‚˜: ì§€ë¶• ë’¤ìª½ (ìœ„ì„± ì‹ í˜¸ ìˆ˜ì‹  ìµœì í™”)
        self.gps_antenna = (
            self.base_x - 1.0,  # ì°¨ëŸ‰ ë’¤ìª½
            self.base_y,        # ì°¨ëŸ‰ ì¤‘ì‹¬ì„ 
            self.base_z + 1.5   # ìµœëŒ€í•œ ë†’ì€ ìœ„ì¹˜
        )
    
    def get_sensor_offset(self, sensor_type):
        """íŠ¹ì • ì„¼ì„œì˜ ì°¨ëŸ‰ ê¸°ì¤€ì  ëŒ€ë¹„ ì˜¤í”„ì…‹ ë°˜í™˜"""
        positions = {
            'lidar': self.lidar_position,
            'camera': self.camera_position,
            'radar': self.radar_position,
            'gps': self.gps_antenna
        }
        return positions.get(sensor_type, (0, 0, 0))

# ì‚¬ìš© ì˜ˆì‹œ
vehicle = SensorPositions(0, 0, 0)
print(f"ë¼ì´ë‹¤ ìœ„ì¹˜: {vehicle.lidar_position}")
print(f"ì¹´ë©”ë¼ ìœ„ì¹˜: {vehicle.camera_position}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ë¼ì´ë‹¤ ìœ„ì¹˜: (0.5, 0, 1.2)
ì¹´ë©”ë¼ ìœ„ì¹˜: (2.0, 0, 0.8)
```

---

## 2. ì•ˆì „ì„± ê¸°ì¤€ì 

ì¶©ëŒ ê°ì§€ì™€ ì•ˆì „ì„± í™•ë³´ë¥¼ ìœ„í•œ í•µì‹¬ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤. ì´ë“¤ ì ë“¤ì€ ì°¨ëŸ‰ì˜ ë¬¼ë¦¬ì  ê²½ê³„ë¥¼ ì •ì˜í•˜ê³  ì¶©ëŒ ìœ„í—˜ì„ ì‚¬ì „ì— ê°ì§€í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

```python
import math

class SafetyReferencePoints:
    def __init__(self, vehicle_length=4.5, vehicle_width=1.8, vehicle_height=1.5):
        self.length = vehicle_length
        self.width = vehicle_width
        self.height = vehicle_height
        
        # ì¶©ëŒ ê°ì§€ìš© ì£¼ìš” ì§€ì ë“¤ ì •ì˜
        self.safety_points = {
            'front_bumper': (self.length/2, 0, 0),      # ì „ë°© ì¶©ëŒ ê°ì§€
            'rear_bumper': (-self.length/2, 0, 0),      # í›„ë°© ì¶©ëŒ ê°ì§€
            'left_side': (0, self.width/2, 0),          # ì¢Œì¸¡ ì¶©ëŒ ê°ì§€
            'right_side': (0, -self.width/2, 0),        # ìš°ì¸¡ ì¶©ëŒ ê°ì§€
            'roof_corners': [                            # ë†’ì´ ì œí•œ ê°ì§€
                (self.length/2, self.width/2, self.height),
                (self.length/2, -self.width/2, self.height),
                (-self.length/2, self.width/2, self.height),
                (-self.length/2, -self.width/2, self.height)
            ]
        }
    
    def check_collision_risk(self, obstacle_position, safety_margin=0.5):
        """ì¥ì• ë¬¼ê³¼ì˜ ì¶©ëŒ ìœ„í—˜ë„ ê³„ì‚°"""
        min_distance = float('inf')
        closest_point = None
        
        for point_name, position in self.safety_points.items():
            if point_name != 'roof_corners':  # ë£¨í”„ ì½”ë„ˆëŠ” ë³„ë„ ì²˜ë¦¬
                distance = math.sqrt(
                    (obstacle_position[0] - position[0])**2 +
                    (obstacle_position[1] - position[1])**2
                )
                
                if distance < min_distance:
                    min_distance = distance
                    closest_point = point_name
        
        is_dangerous = min_distance < safety_margin
        return {
            'is_dangerous': is_dangerous,
            'distance': min_distance,
            'closest_point': closest_point,
            'safety_margin': safety_margin
        }
    
    def get_safety_envelope(self, expansion_factor=1.2):
        """ì•ˆì „ ì—¬ìœ  ê³µê°„ì„ í¬í•¨í•œ ì°¨ëŸ‰ ì™¸ê³½ ê³„ì‚°"""
        expanded_points = {}
        for point_name, position in self.safety_points.items():
            if point_name != 'roof_corners':
                expanded_points[point_name] = (
                    position[0] * expansion_factor,
                    position[1] * expansion_factor,
                    position[2]
                )
        return expanded_points

# ì‚¬ìš© ì˜ˆì‹œ
safety_system = SafetyReferencePoints()
obstacle_pos = (3.0, 0.5, 0)  # ì „ë°© ìš°ì¸¡ ì¥ì• ë¬¼
risk_assessment = safety_system.check_collision_risk(obstacle_pos)

print(f"ì¶©ëŒ ìœ„í—˜: {risk_assessment['is_dangerous']}")
print(f"ìµœê·¼ì ‘ ê±°ë¦¬: {risk_assessment['distance']:.2f}m")
print(f"ê°€ì¥ ê°€ê¹Œìš´ ì§€ì : {risk_assessment['closest_point']}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì¶©ëŒ ìœ„í—˜: False
ìµœê·¼ì ‘ ê±°ë¦¬: 0.58m
ê°€ì¥ ê°€ê¹Œìš´ ì§€ì : front_bumper
```

---

## 3. ì¡°í–¥ ê´€ë ¨ ê¸°ì¤€ì 

ì°¨ëŸ‰ì˜ ì¡°í–¥ ì œì–´ë¥¼ ìœ„í•œ ë‹¤ì–‘í•œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤. Bicycle Modelì„ ê¸°ë°˜ìœ¼ë¡œ í•œ ì¡°í–¥ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©ë˜ëŠ” í•µì‹¬ ê°œë…ë“¤ì„ í¬í•¨í•©ë‹ˆë‹¤.

```python
class SteeringReferencePoints:
    def __init__(self, wheelbase=2.7, front_overhang=0.9, rear_overhang=0.9):
        self.wheelbase = wheelbase  # ì¶•ê°„ê±°ë¦¬
        self.front_overhang = front_overhang  # ì•ìª½ ì˜¤ë²„í–‰
        self.rear_overhang = rear_overhang    # ë’¤ìª½ ì˜¤ë²„í–‰
        
        # ì¡°í–¥ ê´€ë ¨ ì£¼ìš” ê¸°ì¤€ì ë“¤
        self.reference_points = {
            'rear_wheel_center': (0, 0, 0),  # í›„ë¥œ ì¤‘ì‹¬ (ì¼ë°˜ì  ê¸°ì¤€)
            'front_wheel_center': (self.wheelbase, 0, 0),  # ì „ë¥œ ì¤‘ì‹¬
            'wheelbase_center': (self.wheelbase/2, 0, 0),  # ì¶•ê°„ê±°ë¦¬ ì¤‘ì 
            'cog_center': (self.wheelbase*0.4, 0, 0),  # ë¬´ê²Œì¤‘ì‹¬ (ì¼ë°˜ì ìœ¼ë¡œ í›„ì¶•ì—ì„œ 40% ì§€ì )
            'geometric_center': (self.wheelbase/2, 0, 0)  # ê¸°í•˜í•™ì  ì¤‘ì‹¬
        }
    
    def calculate_turning_radius(self, steering_angle_deg, reference_point='rear_wheel_center'):
        """ì¡°í–¥ê°ì— ë”°ë¥¸ íšŒì „ ë°˜ê²½ ê³„ì‚° (Bicycle Model ê¸°ë°˜)"""
        steering_angle_rad = math.radians(steering_angle_deg)
        
        if abs(steering_angle_rad) < 0.001:  # ì§ì§„ ì‹œ
            return float('inf')
        
        # í›„ì¶• ì¤‘ì‹¬ ê¸°ì¤€ íšŒì „ ë°˜ê²½
        base_radius = self.wheelbase / math.tan(abs(steering_angle_rad))
        
        # ê¸°ì¤€ì ì— ë”°ë¥¸ ë³´ì •
        if reference_point == 'front_wheel_center':
            # ì „ë¥œ ì¤‘ì‹¬ì˜ ê²½ìš° ë” ë„“ì€ íšŒì „ ë°˜ê²½
            radius = base_radius / math.cos(steering_angle_rad)
        elif reference_point == 'cog_center':
            # ë¬´ê²Œì¤‘ì‹¬ ê¸°ì¤€ ë³´ì •
            cog_offset = self.wheelbase * 0.4
            radius = math.sqrt(base_radius**2 + cog_offset**2)
        else:  # rear_wheel_center (ê¸°ë³¸ê°’)
            radius = base_radius
            
        return radius
    
    def get_instantaneous_center_of_rotation(self, steering_angle_deg):
        """ìˆœê°„ íšŒì „ ì¤‘ì‹¬ ê³„ì‚°"""
        steering_angle_rad = math.radians(steering_angle_deg)
        
        if abs(steering_angle_rad) < 0.001:
            return None  # ì§ì§„ ì‹œì—ëŠ” íšŒì „ ì¤‘ì‹¬ì´ ë¬´í•œëŒ€
        
        # í›„ì¶• ì¤‘ì‹¬ì—ì„œ íšŒì „ ì¤‘ì‹¬ê¹Œì§€ì˜ ê±°ë¦¬
        distance = self.wheelbase / math.tan(abs(steering_angle_rad))
        
        # íšŒì „ ì¤‘ì‹¬ì˜ ìœ„ì¹˜ (í›„ì¶• ì¤‘ì‹¬ ê¸°ì¤€)
        if steering_angle_deg > 0:  # ì¢ŒíšŒì „
            icr_position = (0, distance, 0)
        else:  # ìš°íšŒì „
            icr_position = (0, -distance, 0)
            
        return icr_position

# ì‚¬ìš© ì˜ˆì‹œ
steering_system = SteeringReferencePoints()

# 15ë„ ì¢ŒíšŒì „ ì‹œ íšŒì „ ë°˜ê²½ ê³„ì‚°
steering_angle = 15  # ë„
radius = steering_system.calculate_turning_radius(steering_angle)
icr = steering_system.get_instantaneous_center_of_rotation(steering_angle)

print(f"ì¡°í–¥ê°: {steering_angle}ë„")
print(f"íšŒì „ ë°˜ê²½: {radius:.2f}m")
print(f"ìˆœê°„ íšŒì „ ì¤‘ì‹¬: {icr}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì¡°í–¥ê°: 15ë„
íšŒì „ ë°˜ê²½: 10.07m
ìˆœê°„ íšŒì „ ì¤‘ì‹¬: (0, 10.07, 0)
```

---

## 4. ì£¼ì°¨/ì •ë°€ ì œì–´ ê¸°ì¤€ì 

ì£¼ì°¨ë‚˜ ì •ë°€í•œ ì¡°ì‘ì´ í•„ìš”í•œ ìƒí™©ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤. ì°¨ëŸ‰ì˜ ëª¨ì„œë¦¬ì™€ ê²½ê³„ë¥¼ ì •í™•íˆ íŒŒì•…í•˜ì—¬ ì¶©ëŒ ì—†ëŠ” ì£¼ì°¨ë¥¼ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

```python
class ParkingReferencePoints:
    def __init__(self, vehicle_length=4.5, vehicle_width=1.8):
        self.length = vehicle_length
        self.width = vehicle_width
        
        # ì£¼ì°¨ ì‹œ ì¤‘ìš”í•œ ì°¨ëŸ‰ ëª¨ì„œë¦¬ë“¤
        self.vehicle_corners = {
            'front_left_corner': (self.length/2, self.width/2, 0),
            'front_right_corner': (self.length/2, -self.width/2, 0),
            'rear_left_corner': (-self.length/2, self.width/2, 0),
            'rear_right_corner': (-self.length/2, -self.width/2, 0)
        }
        
        # ì£¼ì°¨ ì‹œ ì¶”ê°€ í™•ì¸ ì§€ì ë“¤
        self.critical_points = {
            'front_center': (self.length/2, 0, 0),
            'rear_center': (-self.length/2, 0, 0),
            'left_center': (0, self.width/2, 0),
            'right_center': (0, -self.width/2, 0),
            'geometric_center': (0, 0, 0)
        }
    
    def check_parking_clearance(self, parking_space_corners, clearance_margin=0.3):
        """ì£¼ì°¨ ê³µê°„ê³¼ ì°¨ëŸ‰ ê°„ ì—¬ìœ  ê³µê°„ í™•ì¸"""
        # ì£¼ì°¨ ê³µê°„ í¬ê¸° ê³„ì‚°
        space_length = abs(parking_space_corners[1][0] - parking_space_corners[0][0])
        space_width = abs(parking_space_corners[2][1] - parking_space_corners[0][1])
        
        # í•„ìš”í•œ ìµœì†Œ ê³µê°„ (ì°¨ëŸ‰ í¬ê¸° + ì—¬ìœ  ê³µê°„)
        required_length = self.length + 2 * clearance_margin
        required_width = self.width + 2 * clearance_margin
        
        length_ok = space_length >= required_length
        width_ok = space_width >= required_width
        
        return {
            'can_park': length_ok and width_ok,
            'length_clearance': space_length - self.length,
            'width_clearance': space_width - self.width,
            'length_sufficient': length_ok,
            'width_sufficient': width_ok
        }
    
    def calculate_parking_trajectory(self, target_position, current_position, parking_type='parallel'):
        """ì£¼ì°¨ ê¶¤ì  ê³„ì‚°"""
        if parking_type == 'parallel':
            # í‰í–‰ ì£¼ì°¨ ê¶¤ì 
            trajectory_points = []
            
            # 1ë‹¨ê³„: í›„ì§„ ì‹œì‘ì ê¹Œì§€ ì´ë™
            approach_point = (
                target_position[0] - self.length,
                target_position[1] + self.width,
                0
            )
            trajectory_points.append(approach_point)
            
            # 2ë‹¨ê³„: í›„ì§„í•˜ë©° ì¡°í–¥
            reverse_point = (
                target_position[0] - self.length/2,
                target_position[1] + self.width/2,
                0
            )
            trajectory_points.append(reverse_point)
            
            # 3ë‹¨ê³„: ìµœì¢… ì£¼ì°¨ ìœ„ì¹˜
            trajectory_points.append(target_position)
            
        elif parking_type == 'perpendicular':
            # ìˆ˜ì§ ì£¼ì°¨ ê¶¤ì 
            trajectory_points = []
            
            # 1ë‹¨ê³„: ì§„ì… ì¤€ë¹„ ìœ„ì¹˜
            approach_point = (
                target_position[0] - self.length,
                target_position[1],
                0
            )
            trajectory_points.append(approach_point)
            
            # 2ë‹¨ê³„: ìµœì¢… ì£¼ì°¨ ìœ„ì¹˜
            trajectory_points.append(target_position)
        
        return trajectory_points
    
    def get_corner_positions_at_pose(self, vehicle_x, vehicle_y, vehicle_heading):
        """íŠ¹ì • ìœ„ì¹˜ì™€ ë°©í–¥ì—ì„œì˜ ì°¨ëŸ‰ ëª¨ì„œë¦¬ ìœ„ì¹˜ ê³„ì‚°"""
        cos_h = math.cos(vehicle_heading)
        sin_h = math.sin(vehicle_heading)
        
        corner_positions = {}
        for corner_name, (local_x, local_y, local_z) in self.vehicle_corners.items():
            # íšŒì „ ë³€í™˜ ì ìš©
            global_x = vehicle_x + (local_x * cos_h - local_y * sin_h)
            global_y = vehicle_y + (local_x * sin_h + local_y * cos_h)
            corner_positions[corner_name] = (global_x, global_y, local_z)
        
        return corner_positions

# ì‚¬ìš© ì˜ˆì‹œ
parking_system = ParkingReferencePoints()

# ì£¼ì°¨ ê³µê°„ ì •ì˜ (ê¸¸ì´ 5.5m, í­ 2.3m)
parking_space = [
    (0, 0, 0),    # ì¢Œí•˜ë‹¨
    (5.5, 0, 0),  # ìš°í•˜ë‹¨
    (5.5, 2.3, 0), # ìš°ìƒë‹¨
    (0, 2.3, 0)   # ì¢Œìƒë‹¨
]

clearance_check = parking_system.check_parking_clearance(parking_space)
print(f"ì£¼ì°¨ ê°€ëŠ¥: {clearance_check['can_park']}")
print(f"ê¸¸ì´ ì—¬ìœ : {clearance_check['length_clearance']:.2f}m")
print(f"í­ ì—¬ìœ : {clearance_check['width_clearance']:.2f}m")

# ì£¼ì°¨ ê¶¤ì  ê³„ì‚°
target_pos = (2.75, 1.15, 0)  # ì£¼ì°¨ ê³µê°„ ì¤‘ì‹¬
current_pos = (0, 3, 0)       # í˜„ì¬ ìœ„ì¹˜
trajectory = parking_system.calculate_parking_trajectory(target_pos, current_pos, 'parallel')
print(f"ì£¼ì°¨ ê¶¤ì  ì ë“¤: {len(trajectory)}ê°œ")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì£¼ì°¨ ê°€ëŠ¥: True
ê¸¸ì´ ì—¬ìœ : 1.00m
í­ ì—¬ìœ : 0.50m
ì£¼ì°¨ ê¶¤ì  ì ë“¤: 3ê°œ
```

---

## 5. ë™ì  ê¸°ì¤€ì  (ìƒí™©ë³„)

ì£¼í–‰ ìƒí™©ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ë³€ê²½ë˜ëŠ” ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤. ê° ì£¼í–‰ ëª¨ë“œì— ìµœì í™”ëœ ê¸°ì¤€ì ì„ ì„ íƒí•˜ì—¬ ì œì–´ ì •í™•ë„ë¥¼ ë†’ì…ë‹ˆë‹¤.

```python
class DynamicReferencePoints:
    def __init__(self, vehicle_config):
        self.vehicle_config = vehicle_config
        
        # ìƒí™©ë³„ ìµœì  ê¸°ì¤€ì  ì •ì˜
        self.mode_reference_points = {
            'HIGHWAY': 'rear_axle_center',      # ê³ ì† ì£¼í–‰ - ì•ˆì •ì„± ì¤‘ì‹œ
            'PARKING': 'geometric_center',      # ì£¼ì°¨ - ì •ë°€ë„ ì¤‘ì‹œ
            'LANE_CHANGE': 'front_axle_center', # ì°¨ì„  ë³€ê²½ - ë°˜ì‘ì„± ì¤‘ì‹œ
            'INTERSECTION': 'front_bumper',     # êµì°¨ë¡œ - ì•ˆì „ì„± ì¤‘ì‹œ
            'REVERSE': 'rear_bumper',           # í›„ì§„ - í›„ë°© ì •ë°€ë„ ì¤‘ì‹œ
            'SENSOR_FUSION': 'sensor_fusion_center'  # ì„¼ì„œ ìœµí•© ìµœì í™”
        }
    
    def get_current_reference_point(self, driving_mode, vehicle_speed=0, sensor_data=None):
        """í˜„ì¬ ìƒí™©ì— ë§ëŠ” ìµœì  ê¸°ì¤€ì  ì„ íƒ"""
        
        # ì†ë„ ê¸°ë°˜ ì¡°ì •
        if vehicle_speed > 80:  # ê³ ì† ì£¼í–‰
            base_reference = self.mode_reference_points['HIGHWAY']
        elif vehicle_speed < 5:  # ì €ì† ì£¼í–‰
            base_reference = self.mode_reference_points['PARKING']
        else:
            base_reference = self.mode_reference_points.get(driving_mode, 'rear_axle_center')
        
        # ì„¼ì„œ ë°ì´í„° ê¸°ë°˜ ì¶”ê°€ ì¡°ì •
        if sensor_data and 'sensor_fusion_active' in sensor_data:
            if sensor_data['sensor_fusion_active']:
                base_reference = self.mode_reference_points['SENSOR_FUSION']
        
        return base_reference
    
    def calculate_reference_position(self, reference_type, vehicle_position, vehicle_heading):
        """ê¸°ì¤€ì  íƒ€ì…ì— ë”°ë¥¸ ì‹¤ì œ ìœ„ì¹˜ ê³„ì‚°"""
        vehicle_x, vehicle_y, vehicle_z = vehicle_position
        
        # ì°¨ëŸ‰ ê¸°í•˜í•™ì  íŒŒë¼ë¯¸í„°
        wheelbase = self.vehicle_config.get('wheelbase', 2.7)
        front_overhang = self.vehicle_config.get('front_overhang', 0.9)
        rear_overhang = self.vehicle_config.get('rear_overhang', 0.9)
        
        # ë¡œì»¬ ì¢Œí‘œê³„ì—ì„œì˜ ì˜¤í”„ì…‹ ì •ì˜
        local_offsets = {
            'rear_axle_center': (0, 0, 0),
            'front_axle_center': (wheelbase, 0, 0),
            'geometric_center': (wheelbase/2, 0, 0),
            'front_bumper': (wheelbase + front_overhang, 0, 0),
            'rear_bumper': (-rear_overhang, 0, 0),
            'sensor_fusion_center': (wheelbase*0.3, 0, 0.5)  # ì„¼ì„œ ìœµí•© ìµœì  ìœ„ì¹˜
        }
        
        local_offset = local_offsets.get(reference_type, (0, 0, 0))
        
        # ì°¨ëŸ‰ ë°©í–¥ ê³ ë ¤í•œ ê¸€ë¡œë²Œ ì¢Œí‘œ ë³€í™˜
        cos_h = math.cos(vehicle_heading)
        sin_h = math.sin(vehicle_heading)
        
        global_x = vehicle_x + (local_offset[0] * cos_h - local_offset[1] * sin_h)
        global_y = vehicle_y + (local_offset[0] * sin_h + local_offset[1] * cos_h)
        global_z = vehicle_z + local_offset[2]
        
        return (global_x, global_y, global_z)
    
    def adaptive_reference_selection(self, current_scenario):
        """ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ ì ì‘ì  ê¸°ì¤€ì  ì„ íƒ"""
        scenario_weights = {
            'safety_priority': 0.4,
            'precision_priority': 0.3,
            'efficiency_priority': 0.2,
            'comfort_priority': 0.1
        }
        
        # ì‹œë‚˜ë¦¬ì˜¤ë³„ ê°€ì¤‘ì¹˜ ì ìš©
        if current_scenario.get('emergency_braking', False):
            scenario_weights['safety_priority'] = 0.8
            return 'front_bumper'
        
        if current_scenario.get('tight_parking', False):
            scenario_weights['precision_priority'] = 0.7
            return 'geometric_center'
        
        if current_scenario.get('highway_cruise', False):
            scenario_weights['efficiency_priority'] = 0.6
            return 'rear_axle_center'
        
        return 'rear_axle_center'  # ê¸°ë³¸ê°’

# ì‚¬ìš© ì˜ˆì‹œ
vehicle_config = {
    'wheelbase': 2.7,
    'front_overhang': 0.9,
    'rear_overhang': 0.9
}

dynamic_ref = DynamicReferencePoints(vehicle_config)

# ë‹¤ì–‘í•œ ì£¼í–‰ ìƒí™© ì‹œë®¬ë ˆì´ì…˜
scenarios = [
    {'mode': 'HIGHWAY', 'speed': 100, 'description': 'ê³ ì†ë„ë¡œ ì£¼í–‰'},
    {'mode': 'PARKING', 'speed': 2, 'description': 'ì£¼ì°¨ ì¤‘'},
    {'mode': 'LANE_CHANGE', 'speed': 60, 'description': 'ì°¨ì„  ë³€ê²½'},
    {'mode': 'INTERSECTION', 'speed': 20, 'description': 'êµì°¨ë¡œ í†µê³¼'}
]

for scenario in scenarios:
    ref_point = dynamic_ref.get_current_reference_point(
        scenario['mode'], 
        scenario['speed']
    )
    print(f"{scenario['description']}: {ref_point}")

# íŠ¹ì • ìœ„ì¹˜ì—ì„œì˜ ê¸°ì¤€ì  ê³„ì‚°
vehicle_pos = (100, 50, 0)
vehicle_heading = math.radians(30)  # 30ë„ ë°©í–¥
ref_pos = dynamic_ref.calculate_reference_position(
    'front_axle_center', 
    vehicle_pos, 
    vehicle_heading
)
print(f"ì „ì¶• ì¤‘ì‹¬ ìœ„ì¹˜: ({ref_pos[0]:.2f}, {ref_pos[1]:.2f}, {ref_pos[2]:.2f})")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ê³ ì†ë„ë¡œ ì£¼í–‰: rear_axle_center
ì£¼ì°¨ ì¤‘: geometric_center
ì°¨ì„  ë³€ê²½: front_axle_center
êµì°¨ë¡œ í†µê³¼: intersection
ì „ì¶• ì¤‘ì‹¬ ìœ„ì¹˜: (102.34, 51.35, 0.00)
```

---

## 6. ì¢Œí‘œê³„ë³„ ê¸°ì¤€ì 

ì„œë¡œ ë‹¤ë¥¸ ì¢Œí‘œê³„ì—ì„œ ì‚¬ìš©ë˜ëŠ” ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤. ê¸€ë¡œë²Œ, ë¡œì»¬, ì„¼ì„œ ì¢Œí‘œê³„ ê°„ì˜ ë³€í™˜ê³¼ ì¼ê´€ì„± ìœ ì§€ê°€ í•µì‹¬ì…ë‹ˆë‹¤.

```python
import numpy as np

class CoordinateSystemReferences:
    def __init__(self):
        # ì¢Œí‘œê³„ë³„ ê¸°ì¤€ì  ì •ì˜
        self.coordinate_systems = {
            'global': 'rear_axle_gps',        # GPS ê¸°ì¤€ ê¸€ë¡œë²Œ ì¢Œí‘œ
            'local': 'vehicle_center',        # ì°¨ëŸ‰ ì¤‘ì‹¬ ê¸°ì¤€ ë¡œì»¬ ì¢Œí‘œ
            'sensor': 'lidar_origin',         # ì„¼ì„œ ì›ì  ê¸°ì¤€
            'map': 'map_origin',              # ì§€ë„ ì¢Œí‘œê³„ ê¸°ì¤€
            'lane': 'lane_center_line'        # ì°¨ì„  ì¤‘ì‹¬ì„  ê¸°ì¤€
        }
    
    def global_to_local_transform(self, global_position, vehicle_global_pos, vehicle_heading):
        """ê¸€ë¡œë²Œ ì¢Œí‘œë¥¼ ì°¨ëŸ‰ ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜"""
        # í‰í–‰ ì´ë™
        translated = np.array(global_position) - np.array(vehicle_global_pos)
        
        # íšŒì „ ë³€í™˜ (ì°¨ëŸ‰ ë°©í–¥ ê¸°ì¤€)
        cos_h = math.cos(-vehicle_heading)  # ì—­íšŒì „
        sin_h = math.sin(-vehicle_heading)
        
        rotation_matrix = np.array([
            [cos_h, -sin_h, 0],
            [sin_h, cos_h, 0],
            [0, 0, 1]
        ])
        
        if len(translated) == 2:
            translated = np.append(translated, 0)  # z ì¢Œí‘œ ì¶”ê°€
        
        local_position = rotation_matrix @ translated
        return tuple(local_position)
    
    def local_to_global_transform(self, local_position, vehicle_global_pos, vehicle_heading):
        """ì°¨ëŸ‰ ë¡œì»¬ ì¢Œí‘œë¥¼ ê¸€ë¡œë²Œ ì¢Œí‘œë¡œ ë³€í™˜"""
        # íšŒì „ ë³€í™˜ (ì°¨ëŸ‰ ë°©í–¥ ì ìš©)
        cos_h = math.cos(vehicle_heading)
        sin_h = math.sin(vehicle_heading)
        
        rotation_matrix = np.array([
            [cos_h, -sin_h, 0],
            [sin_h, cos_h, 0],
            [0, 0, 1]
        ])
        
        if len(local_position) == 2:
            local_position = list(local_position) + [0]  # z ì¢Œí‘œ ì¶”ê°€
        
        rotated = rotation_matrix @ np.array(local_position)
        
        # í‰í–‰ ì´ë™
        global_position = rotated + np.array(vehicle_global_pos)
        return tuple(global_position)
    
    def sensor_to_vehicle_transform(self, sensor_data, sensor_offset, sensor_orientation=0):
        """ì„¼ì„œ ì¢Œí‘œë¥¼ ì°¨ëŸ‰ ì¢Œí‘œë¡œ ë³€í™˜"""
        # ì„¼ì„œ ë°©í–¥ ë³´ì •
        cos_s = math.cos(sensor_orientation)
        sin_s = math.sin(sensor_orientation)
        
        sensor_rotation = np.array([
            [cos_s, -sin_s, 0],
            [sin_s, cos_s, 0],
            [0, 0, 1]
        ])
        
        # ì„¼ì„œ ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ì¢Œí‘œê³„ë¡œ ë³€í™˜
        if len(sensor_data) == 2:
            sensor_data = list(sensor_data) + [0]
        
        rotated_data = sensor_rotation @ np.array(sensor_data)
        vehicle_coordinates = rotated_data + np.array(sensor_offset)
        
        return tuple(vehicle_coordinates)
    
    def get_coordinate_reference_chain(self, target_coordinate_system):
        """ì¢Œí‘œê³„ ë³€í™˜ ì²´ì¸ ë°˜í™˜"""
        transformation_chain = {
            'sensor_to_vehicle': [
                'sensor_rotation',
                'sensor_translation'
            ],
            'vehicle_to_global': [
                'vehicle_rotation',
                'vehicle_translation'
            ],
            'global_to_map': [
                'map_projection',
                'map_alignment'
            ]
        }
        return transformation_chain
    
    def multi_coordinate_fusion(self, sensor_readings):
        """ë‹¤ì¤‘ ì¢Œí‘œê³„ ë°ì´í„° ìœµí•©"""
        fused_data = {}
        
        for sensor_name, reading in sensor_readings.items():
            # ê° ì„¼ì„œë³„ ì¢Œí‘œê³„ ë³€í™˜
            if sensor_name == 'lidar':
                sensor_offset = (0.5, 0, 1.2)
                vehicle_coords = self.sensor_to_vehicle_transform(
                    reading['position'], 
                    sensor_offset
                )
            elif sensor_name == 'camera':
                sensor_offset = (2.0, 0, 0.8)
                vehicle_coords = self.sensor_to_vehicle_transform(
                    reading['position'], 
                    sensor_offset
                )
            elif sensor_name == 'gps':
                # GPSëŠ” ì´ë¯¸ ê¸€ë¡œë²Œ ì¢Œí‘œ
                vehicle_coords = reading['position']
            
            fused_data[sensor_name] = {
                'original': reading['position'],
                'vehicle_coordinates': vehicle_coords,
                'confidence': reading.get('confidence', 1.0)
            }
        
        return fused_data

# ì‚¬ìš© ì˜ˆì‹œ
coord_system = CoordinateSystemReferences()

# ì°¨ëŸ‰ í˜„ì¬ ìœ„ì¹˜ (ê¸€ë¡œë²Œ ì¢Œí‘œ)
vehicle_global_pos = (1000.0, 2000.0, 0.0)
vehicle_heading = math.radians(45)  # 45ë„ ë°©í–¥

# ë¡œì»¬ ì¢Œí‘œì˜ í•œ ì ì„ ê¸€ë¡œë²Œë¡œ ë³€í™˜
local_point = (5.0, 2.0, 0.0)  # ì°¨ëŸ‰ ì•ìª½ ìš°ì¸¡ 5m, ìš°ì¸¡ 2m
global_point = coord_system.local_to_global_transform(
    local_point, vehicle_global_pos, vehicle_heading
)

print(f"ë¡œì»¬ ì¢Œí‘œ {local_point} -> ê¸€ë¡œë²Œ ì¢Œí‘œ ({global_point[0]:.2f}, {global_point[1]:.2f})")

# ì„¼ì„œ ë°ì´í„° ìœµí•© ì˜ˆì‹œ
sensor_readings = {
    'lidar': {'position': (10.0, 0.0), 'confidence': 0.95},
    'camera': {'position': (12.0, -1.0), 'confidence': 0.88},
    'gps': {'position': (1000.0, 2000.0), 'confidence': 0.92}
}

fused_data = coord_system.multi_coordinate_fusion(sensor_readings)
for sensor, data in fused_data.items():
    print(f"{sensor}: ì°¨ëŸ‰ ì¢Œí‘œ {data['vehicle_coordinates']}")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ë¡œì»¬ ì¢Œí‘œ (5.0, 2.0, 0.0) -> ê¸€ë¡œë²Œ ì¢Œí‘œ (1002.12, 2004.95)
lidar: ì°¨ëŸ‰ ì¢Œí‘œ (10.5, 0.0, 1.2)
camera: ì°¨ëŸ‰ ì¢Œí‘œ (14.0, -1.0, 0.8)
gps: ì°¨ëŸ‰ ì¢Œí‘œ (1000.0, 2000.0, 0.0)
```

---

## 7. ì œì–´ ì‹œìŠ¤í…œë³„ ê³ ë ¤ì‚¬í•­

ê° ì œì–´ ì‹œìŠ¤í…œì˜ ëª©ì ì— ë”°ë¼ ìµœì í™”ëœ ê¸°ì¤€ì  ì„ íƒ ê°€ì´ë“œì…ë‹ˆë‹¤.

```python
class ControlSystemReferences:
    def __init__(self):
        # ì œì–´ ì‹œìŠ¤í…œë³„ ìµœì  ê¸°ì¤€ì  ë§¤í•‘
        self.control_references = {
            'path_following': 'rear_axle_center',      # ìˆ˜í•™ì  ë‹¨ìˆœí•¨
            'obstacle_avoidance': 'vehicle_boundary',   # ì•ˆì „ ë§ˆì§„ í™•ë³´
            'lane_keeping': 'vehicle_centerline',      # ì°¨ì„  ì¤‘ì•™ ìœ ì§€
            'intersection_crossing': 'front_bumper',    # ì§„ì… íƒ€ì´ë° ìµœì í™”
            'reverse_parking': 'rear_bumper',          # í›„ì§„ ì •ë°€ë„
            'adaptive_cruise': 'front_center',         # ì°¨ê°„ê±°ë¦¬ ì œì–´
            'emergency_braking': 'front_bumper'        # ìµœëŒ€ ì•ˆì „ì„±
        }
    
    def get_control_reference(self, control_system, vehicle_state):
        """ì œì–´ ì‹œìŠ¤í…œì— ë§ëŠ” ê¸°ì¤€ì  ë°˜í™˜"""
        base_reference = self.control_references.get(control_system, 'rear_axle_center')
        
        # ì°¨ëŸ‰ ìƒíƒœì— ë”°ë¥¸ ë™ì  ì¡°ì •
        if vehicle_state.get('speed', 0) > 50:  # ê³ ì† ì£¼í–‰
            if control_system == 'path_following':
                return 'rear_axle_center'  # ì•ˆì •ì„± ìš°ì„ 
        elif vehicle_state.get('speed', 0) < 10:  # ì €ì† ì£¼í–‰
            if control_system in ['path_following', 'lane_keeping']:
                return 'geometric_center'  # ì •ë°€ë„ ìš°ì„ 
        
        return base_reference
    
    def calculate_control_error(self, control_system, target_path, current_position, vehicle_heading):
        """ì œì–´ ì‹œìŠ¤í…œë³„ ì˜¤ì°¨ ê³„ì‚°"""
        reference_point = self.get_control_reference(control_system, {'speed': 30})
        
        if control_system == 'path_following':
            # ê²½ë¡œ ì¶”ì¢… ì˜¤ì°¨ (Cross Track Error)
            return self._calculate_cross_track_error(target_path, current_position, vehicle_heading)
        
        elif control_system == 'lane_keeping':
            # ì°¨ì„  ì¤‘ì•™ ìœ ì§€ ì˜¤ì°¨
            return self._calculate_lane_center_error(target_path, current_position)
        
        elif control_system == 'obstacle_avoidance':
            # ì¥ì• ë¬¼ íšŒí”¼ ì•ˆì „ ê±°ë¦¬ ì˜¤ì°¨
            return self._calculate_safety_margin_error(target_path, current_position)
        
        return 0.0
    
    def _calculate_cross_track_error(self, path_points, vehicle_position, vehicle_heading):
        """ê²½ë¡œ ì¶”ì¢… íš¡ë°©í–¥ ì˜¤ì°¨ ê³„ì‚°"""
        if len(path_points) < 2:
            return 0.0
        
        # ê°€ì¥ ê°€ê¹Œìš´ ê²½ë¡œ ì  ì°¾ê¸°
        min_distance = float('inf')
        closest_segment_idx = 0
        
        for i in range(len(path_points) - 1):
            distance = self._point_to_line_distance(
                vehicle_position, path_points[i], path_points[i + 1]
            )
            if distance < min_distance:
                min_distance = distance
                closest_segment_idx = i
        
        # ê²½ë¡œ ë°©í–¥ê³¼ ì°¨ëŸ‰ ë°©í–¥ ë¹„êµ
        path_vector = (
            path_points[closest_segment_idx + 1][0] - path_points[closest_segment_idx][0],
            path_points[closest_segment_idx + 1][1] - path_points[closest_segment_idx][1]
        )
        path_heading = math.atan2(path_vector[1], path_vector[0])
        
        # ì™¸ì ì„ ì´ìš©í•œ ì¢Œìš° íŒë‹¨
        cross_product = (
            (vehicle_position[0] - path_points[closest_segment_idx][0]) * path_vector[1] -
            (vehicle_position[1] - path_points[closest_segment_idx][1]) * path_vector[0]
        )
        
        return min_distance if cross_product > 0 else -min_distance
    
    def _point_to_line_distance(self, point, line_start, line_end):
        """ì ê³¼ ì§ì„  ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°"""
        line_vec = (line_end[0] - line_start[0], line_end[1] - line_start[1])
        point_vec = (point[0] - line_start[0], point[1] - line_start[1])
        
        line_len = math.sqrt(line_vec[0]**2 + line_vec[1]**2)
        if line_len == 0:
            return math.sqrt(point_vec[0]**2 + point_vec[1]**2)
        
        line_unitvec = (line_vec[0] / line_len, line_vec[1] / line_len)
        proj_length = point_vec[0] * line_unitvec[0] + point_vec[1] * line_unitvec[1]
        
        if proj_length < 0:
            return math.sqrt(point_vec[0]**2 + point_vec[1]**2)
        elif proj_length > line_len:
            end_vec = (point[0] - line_end[0], point[1] - line_end[1])
            return math.sqrt(end_vec[0]**2 + end_vec[1]**2)
        else:
            proj_point = (
                line_start[0] + proj_length * line_unitvec[0],
                line_start[1] + proj_length * line_unitvec[1]
            )
            return math.sqrt((point[0] - proj_point[0])**2 + (point[1] - proj_point[1])**2)
    
    def _calculate_lane_center_error(self, lane_center_line, vehicle_position):
        """ì°¨ì„  ì¤‘ì•™ ìœ ì§€ ì˜¤ì°¨ ê³„ì‚°"""
        return self._point_to_line_distance(vehicle_position, lane_center_line[0], lane_center_line[-1])
    
    def _calculate_safety_margin_error(self, obstacles, vehicle_position):
        """ì•ˆì „ ê±°ë¦¬ ë§ˆì§„ ì˜¤ì°¨ ê³„ì‚°"""
        min_distance = float('inf')
        for obstacle in obstacles:
            distance = math.sqrt(
                (vehicle_position[0] - obstacle[0])**2 + 
                (vehicle_position[1] - obstacle[1])**2
            )
            min_distance = min(min_distance, distance)
        
        safety_margin = 2.0  # ìµœì†Œ ì•ˆì „ ê±°ë¦¬ 2m
        return max(0, safety_margin - min_distance)

# ì‚¬ìš© ì˜ˆì‹œ
control_system = ControlSystemReferences()

# ë‹¤ì–‘í•œ ì œì–´ ì‹œìŠ¤í…œì˜ ê¸°ì¤€ì  í™•ì¸
control_types = ['path_following', 'lane_keeping', 'obstacle_avoidance', 'emergency_braking']
vehicle_state = {'speed': 45}

for control_type in control_types:
    reference = control_system.get_control_reference(control_type, vehicle_state)
    print(f"{control_type}: {reference}")

# ê²½ë¡œ ì¶”ì¢… ì˜¤ì°¨ ê³„ì‚° ì˜ˆì‹œ
target_path = [(0, 0), (10, 0), (20, 0), (30, 0)]  # ì§ì„  ê²½ë¡œ
current_pos = (15, 1.5)  # ê²½ë¡œì—ì„œ 1.5m ìš°ì¸¡ ì´íƒˆ
vehicle_heading = math.radians(0)  # ì •ë°©í–¥

cross_track_error = control_system.calculate_control_error(
    'path_following', target_path, current_pos, vehicle_heading
)
print(f"ê²½ë¡œ ì¶”ì¢… ì˜¤ì°¨: {cross_track_error:.2f}m")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
path_following: rear_axle_center
lane_keeping: vehicle_centerline
obstacle_avoidance: vehicle_boundary
emergency_braking: front_bumper
ê²½ë¡œ ì¶”ì¢… ì˜¤ì°¨: 1.50m
```

---

## 8. ë„ë¡œ ë° êµí†µ í™˜ê²½ ê¸°ì¤€ì 

ë„ë¡œ ì¸í”„ë¼ì™€ êµí†µ í™˜ê²½ì— íŠ¹í™”ëœ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

```python
class RoadEnvironmentReferences:
    def __init__(self):
        self.road_references = {
            'lane_center_line': 'lane_marking_center',
            'road_edge': 'road_boundary',
            'intersection_center': 'intersection_geometry_center',
            'stop_line': 'legal_stopping_position',
            'crosswalk': 'pedestrian_crossing_area',
            'traffic_light': 'signal_detection_point'
        }
    
    def get_lane_reference_points(self, lane_width=3.5, lane_marking_width=0.15):
        """ì°¨ì„  ê¸°ì¤€ì ë“¤ ê³„ì‚°"""
        half_lane = lane_width / 2
        marking_offset = lane_marking_width / 2
        
        return {
            'lane_center': (0, 0, 0),
            'left_lane_boundary': (0, half_lane, 0),
            'right_lane_boundary': (0, -half_lane, 0),
            'left_marking_center': (0, half_lane, 0),
            'right_marking_center': (0, -half_lane, 0),
            'left_marking_inner': (0, half_lane - marking_offset, 0),
            'left_marking_outer': (0, half_lane + marking_offset, 0),
            'right_marking_inner': (0, -half_lane + marking_offset, 0),
            'right_marking_outer': (0, -half_lane - marking_offset, 0)
        }
    
    def calculate_intersection_reference_points(self, intersection_geometry):
        """êµì°¨ë¡œ ê¸°ì¤€ì  ê³„ì‚°"""
        # êµì°¨ë¡œ ì¤‘ì‹¬ì  ê³„ì‚°
        center_x = sum(point[0] for point in intersection_geometry) / len(intersection_geometry)
        center_y = sum(point[1] for point in intersection_geometry) / len(intersection_geometry)
        
        intersection_refs = {
            'intersection_center': (center_x, center_y, 0),
            'entry_points': [],
            'exit_points': [],
            'conflict_zones': []
        }
        
        # ì§„ì…ì ê³¼ ì§„ì¶œì  ê³„ì‚° (ë‹¨ìˆœí™”ëœ ì˜ˆì‹œ)
        for i, point in enumerate(intersection_geometry):
            if i % 2 == 0:  # ì§ìˆ˜ ì¸ë±ìŠ¤ëŠ” ì§„ì…ì 
                intersection_refs['entry_points'].append(point)
            else:  # í™€ìˆ˜ ì¸ë±ìŠ¤ëŠ” ì§„ì¶œì 
                intersection_refs['exit_points'].append(point)
        
        return intersection_refs
    
    def get_stop_line_reference(self, stop_line_position, approach_direction):
        """ì •ì§€ì„  ê¸°ì¤€ì  ê³„ì‚°"""
        # ì •ì§€ì„ ì—ì„œ ì°¨ëŸ‰ ì „ë©´ê¹Œì§€ì˜ ê±°ë¦¬ ê³ ë ¤
        vehicle_front_offset = 2.5  # ì°¨ëŸ‰ ì „ë©´ ì˜¤ë²„í–‰ + ì•ˆì „ ì—¬ìœ 
        
        # ì ‘ê·¼ ë°©í–¥ì— ë”°ë¥¸ ì •ì§€ ìœ„ì¹˜ ê³„ì‚°
        if approach_direction == 'north':
            stop_position = (stop_line_position[0], stop_line_position[1] - vehicle_front_offset, 0)
        elif approach_direction == 'south':
            stop_position = (stop_line_position[0], stop_line_position[1] + vehicle_front_offset, 0)
        elif approach_direction == 'east':
            stop_position = (stop_line_position[0] - vehicle_front_offset, stop_line_position[1], 0)
        elif approach_direction == 'west':
            stop_position = (stop_line_position[0] + vehicle_front_offset, stop_line_position[1], 0)
        else:
            stop_position = stop_line_position
        
        return {
            'legal_stop_position': stop_position,
            'stop_line_position': stop_line_position,
            'safety_margin': vehicle_front_offset
        }
    
    def calculate_road_curvature_references(self, road_points):
        """ë„ë¡œ ê³¡ë¥  ê¸°ì¤€ì  ê³„ì‚°"""
        if len(road_points) < 3:
            return {'curvature': 0, 'radius': float('inf')}
        
        curvature_points = []
        
        for i in range(1, len(road_points) - 1):
            # 3ì ì„ ì´ìš©í•œ ê³¡ë¥  ê³„ì‚°
            p1, p2, p3 = road_points[i-1], road_points[i], road_points[i+1]
            
            # ë²¡í„° ê³„ì‚°
            v1 = (p2[0] - p1[0], p2[1] - p1[1])
            v2 = (p3[0] - p2[0], p3[1] - p2[1])
            
            # ê°ë„ ë³€í™”ëŸ‰ ê³„ì‚°
            angle1 = math.atan2(v1[1], v1[0])
            angle2 = math.atan2(v2[1], v2[0])
            angle_diff = angle2 - angle1
            
            # ê°ë„ ì •ê·œí™” (-Ï€ ~ Ï€)
            while angle_diff > math.pi:
                angle_diff -= 2 * math.pi
            while angle_diff < -math.pi:
                angle_diff += 2 * math.pi
            
            # ê±°ë¦¬ ê³„ì‚°
            dist1 = math.sqrt(v1[0]**2 + v1[1]**2)
            dist2 = math.sqrt(v2[0]**2 + v2[1]**2)
            avg_dist = (dist1 + dist2) / 2
            
            # ê³¡ë¥  ê³„ì‚°
            if avg_dist > 0:
                curvature = abs(angle_diff) / avg_dist
                radius = 1 / curvature if curvature > 0 else float('inf')
            else:
                curvature = 0
                radius = float('inf')
            
            curvature_points.append({
                'position': p2,
                'curvature': curvature,
                'radius': radius
            })
        
        return curvature_points

# ì‚¬ìš© ì˜ˆì‹œ
road_env = RoadEnvironmentReferences()

# ì°¨ì„  ê¸°ì¤€ì  ê³„ì‚°
lane_refs = road_env.get_lane_reference_points(lane_width=3.5)
print("ì°¨ì„  ê¸°ì¤€ì ë“¤:")
for ref_name, position in lane_refs.items():
    print(f"  {ref_name}: {position}")

# êµì°¨ë¡œ ê¸°ì¤€ì  ê³„ì‚° (4ê±°ë¦¬ êµì°¨ë¡œ ì˜ˆì‹œ)
intersection_corners = [
    (-5, -5), (5, -5), (5, 5), (-5, 5)  # ì‚¬ê°í˜• êµì°¨ë¡œ
]
intersection_refs = road_env.calculate_intersection_reference_points(intersection_corners)
print(f"\nêµì°¨ë¡œ ì¤‘ì‹¬: {intersection_refs['intersection_center']}")

# ì •ì§€ì„  ê¸°ì¤€ì  ê³„ì‚°
stop_line_pos = (0, 0)
stop_ref = road_env.get_stop_line_reference(stop_line_pos, 'north')
print(f"ì •ì§€ ìœ„ì¹˜: {stop_ref['legal_stop_position']}")

# ë„ë¡œ ê³¡ë¥  ê³„ì‚°
road_curve = [(0, 0), (10, 2), (20, 8), (30, 18)]  # ê³¡ì„  ë„ë¡œ
curvature_data = road_env.calculate_road_curvature_references(road_curve)
print(f"ê³¡ë¥  ë°ì´í„° ì ìˆ˜: {len(curvature_data)}ê°œ")
if curvature_data:
    print(f"ì²« ë²ˆì§¸ ê³¡ë¥ ì  - ê³¡ë¥ : {curvature_data[0]['curvature']:.4f}, ë°˜ê²½: {curvature_data[0]['radius']:.2f}m")
```

**ì‹¤í–‰ ê²°ê³¼:**
```
ì°¨ì„  ê¸°ì¤€ì ë“¤:
  lane_center: (0, 0, 0)
  left_lane_boundary: (0, 1.75, 0)
  right_lane_boundary: (0, -1.75, 0)
  left_marking_center: (0, 1.75, 0)
  right_marking_center: (0, -1.75, 0)
  left_marking_inner: (0, 1.675, 0)
  left_marking_outer: (0, 1.825, 0)
  right_marking_inner: (0, -1.675, 0)
  right_marking_outer: (0, -1.825, 0)

êµì°¨ë¡œ ì¤‘ì‹¬: (0.0, 0.0, 0)
ì •ì§€ ìœ„ì¹˜: (0, -2.5, 0)
ê³¡ë¥  ë°ì´í„° ì ìˆ˜: 2ê°œ
ì²« ë²ˆì§¸ ê³¡ë¥ ì  - ê³¡ë¥ : 0.0063, ë°˜ê²½: 158.11m
```
---

## 9. ë²•ê·œ ë° ê·œì • ê¸°ì¤€ì ë“¤

ì°¨ëŸ‰ì´ êµí†µë²•ê·œë¥¼ ì¤€ìˆ˜í•˜ê³  ê²€ì‚¬ ê¸°ì¤€ì„ ë§Œì¡±í•˜ê¸° ìœ„í•œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
class LegalReferencePoints:
    """êµí†µë²•ê·œ ë° ì°¨ëŸ‰ ê²€ì‚¬ ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_config):
        self.vehicle_config = vehicle_config
        self.legal_boundaries = self._calculate_legal_boundaries()
        self.inspection_points = self._define_inspection_points()
    
    def _calculate_legal_boundaries(self):
        """ë²•ì  ì°¨ëŸ‰ ê²½ê³„ ê³„ì‚°"""
        # ì°¨ëŸ‰ì˜ ë²•ì  ìµœëŒ€ í¬ê¸° (ê¸¸ì´ Ã— í­ Ã— ë†’ì´)
        max_length = 12.0  # 12ë¯¸í„° (ëŒ€í˜• ë²„ìŠ¤/íŠ¸ëŸ­ ê¸°ì¤€)
        max_width = 2.5    # 2.5ë¯¸í„° (ì¼ë°˜ ë„ë¡œ ê¸°ì¤€)
        max_height = 4.0   # 4ë¯¸í„° (êµëŸ‰ í†µê³¼ ê¸°ì¤€)
        
        return {
            'front_legal_boundary': (max_length/2, 0, 0),
            'rear_legal_boundary': (-max_length/2, 0, 0),
            'left_legal_boundary': (0, max_width/2, 0),
            'right_legal_boundary': (0, -max_width/2, 0),
            'top_legal_boundary': (0, 0, max_height)
        }
    
    def _define_inspection_points(self):
        """ì°¨ëŸ‰ ê²€ì‚¬ ê¸°ì¤€ì  ì •ì˜"""
        return {
            'headlight_height': (2.0, 0, 0.8),     # ì „ì¡°ë“± ë†’ì´ ê¸°ì¤€ì 
            'license_plate_position': (-2.5, 0, 0.5),  # ë²ˆí˜¸íŒ ìœ„ì¹˜
            'emission_test_point': (-1.0, -0.5, 0.3),  # ë°°ê¸°ê°€ìŠ¤ ì¸¡ì •ì 
            'brake_test_reference': (0, 0, 0.3)     # ì œë™ ì„±ëŠ¥ ì¸¡ì • ê¸°ì¤€ì 
        }
    
    def check_legal_compliance(self, current_position):
        """í˜„ì¬ ìœ„ì¹˜ê°€ ë²•ì  ê¸°ì¤€ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸"""
        x, y, z = current_position
        
        # ì°¨ì„  ì´íƒˆ ì—¬ë¶€ í™•ì¸
        lane_width = 3.5  # í‘œì¤€ ì°¨ì„  í­ 3.5m
        if abs(y) > lane_width / 2:
            return False, "ì°¨ì„  ì´íƒˆ ìœ„í—˜"
        
        # ë†’ì´ ì œí•œ í™•ì¸ (êµëŸ‰, í„°ë„ ë“±)
        height_limit = 3.8
        if z > height_limit:
            return False, f"ë†’ì´ ì œí•œ ì´ˆê³¼: {z:.2f}m > {height_limit}m"
        
        return True, "ë²•ì  ê¸°ì¤€ ì¤€ìˆ˜"

# ì‚¬ìš© ì˜ˆì‹œ
vehicle_config = {'length': 4.5, 'width': 1.8, 'height': 1.6}
legal_system = LegalReferencePoints(vehicle_config)

# í˜„ì¬ ì°¨ëŸ‰ ìœ„ì¹˜ í™•ì¸
current_pos = (0, 1.2, 1.6)  # x, y, z ì¢Œí‘œ
compliance, message = legal_system.check_legal_compliance(current_pos)
print(f"ë²•ê·œ ì¤€ìˆ˜ ìƒíƒœ: {compliance}, ë©”ì‹œì§€: {message}")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
ë²•ê·œ ì¤€ìˆ˜ ìƒíƒœ: True, ë©”ì‹œì§€: ë²•ì  ê¸°ì¤€ ì¤€ìˆ˜
```

---

## 10. ë¬¼ë¦¬í•™ì /ì—­í•™ì  ê¸°ì¤€ì ë“¤

ì°¨ëŸ‰ì˜ ë™ì—­í•™ì  íŠ¹ì„±ì„ ê³ ë ¤í•œ ë¬¼ë¦¬í•™ì  ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import math
import numpy as np

class PhysicalReferencePoints:
    """ì°¨ëŸ‰ì˜ ë¬¼ë¦¬í•™ì /ì—­í•™ì  ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_mass, wheelbase, track_width):
        self.mass = vehicle_mass          # ì°¨ëŸ‰ ì§ˆëŸ‰ (kg)
        self.wheelbase = wheelbase        # ì¶•ê°„ê±°ë¦¬ (m)
        self.track_width = track_width    # ìœ¤ê±° (m)
        self.gravity = 9.81               # ì¤‘ë ¥ê°€ì†ë„ (m/sÂ²)
        
    def calculate_center_of_rotation(self, steering_angle, velocity):
        """íšŒì „ ì¤‘ì‹¬ ê³„ì‚° (ì„ íšŒ ì‹œ)"""
        if abs(steering_angle) < 0.001:  # ì§ì§„ ì‹œ
            return None
        
        # íšŒì „ ë°˜ì§€ë¦„ ê³„ì‚° (Bicycle Model ê¸°ë°˜)
        turn_radius = self.wheelbase / math.tan(math.radians(steering_angle))
        
        # íšŒì „ ì¤‘ì‹¬ ìœ„ì¹˜ (ì°¨ëŸ‰ ë’¤ì¶• ê¸°ì¤€)
        center_x = 0
        center_y = turn_radius
        
        return (center_x, center_y, 0)
    
    def calculate_instantaneous_center(self, front_wheel_angle, rear_wheel_angle=0):
        """ìˆœê°„ íšŒì „ ì¤‘ì‹¬ ê³„ì‚°"""
        # 4ë¥œ ì¡°í–¥ ì‹œìŠ¤í…œì„ ê³ ë ¤í•œ ìˆœê°„ íšŒì „ ì¤‘ì‹¬
        if abs(front_wheel_angle) < 0.001 and abs(rear_wheel_angle) < 0.001:
            return None  # ì§ì§„ ì‹œì—ëŠ” ìˆœê°„ íšŒì „ ì¤‘ì‹¬ì´ ë¬´í•œëŒ€
        
        # Ackermann ê¸°í•˜í•™ ê¸°ë°˜ ê³„ì‚°
        if abs(rear_wheel_angle) < 0.001:  # ì•ë°”í€´ë§Œ ì¡°í–¥
            ic_y = self.wheelbase / math.tan(math.radians(front_wheel_angle))
        else:  # 4ë¥œ ì¡°í–¥
            ic_y = self.wheelbase / (math.tan(math.radians(front_wheel_angle)) - 
                                   math.tan(math.radians(rear_wheel_angle)))
        
        return (0, ic_y, 0)
    
    def calculate_roll_center(self, suspension_geometry):
        """ë¡¤ ì¤‘ì‹¬ ê³„ì‚° (ì½”ë„ˆë§ ì‹œ ì°¨ì²´ ê¸°ìš¸ì–´ì§ ê¸°ì¤€ì )"""
        # ì„œìŠ¤íœì…˜ ê¸°í•˜í•™ì„ ê³ ë ¤í•œ ë¡¤ ì¤‘ì‹¬ ë†’ì´ ê³„ì‚°
        front_roll_center_height = suspension_geometry.get('front_rc_height', 0.05)
        rear_roll_center_height = suspension_geometry.get('rear_rc_height', 0.08)
        
        # ì°¨ëŸ‰ ë¬´ê²Œì¤‘ì‹¬ì„ ê³ ë ¤í•œ ì „ì²´ ë¡¤ ì¤‘ì‹¬
        cg_position = self.wheelbase * 0.6  # ì¼ë°˜ì ìœ¼ë¡œ ì•ì¶•ì—ì„œ 60% ì§€ì 
        
        roll_center_height = (front_roll_center_height * (self.wheelbase - cg_position) + 
                            rear_roll_center_height * cg_position) / self.wheelbase
        
        return (cg_position, 0, roll_center_height)
    
    def calculate_aerodynamic_center(self, vehicle_dimensions):
        """ê³µê¸°ì—­í•™ ì¤‘ì‹¬ ê³„ì‚°"""
        # ì°¨ëŸ‰ ì „ë©´ íˆ¬ì˜ ë©´ì ì˜ ì¤‘ì‹¬ (ê³µê¸° ì €í•­ ì‘ìš©ì )
        length = vehicle_dimensions['length']
        width = vehicle_dimensions['width']
        height = vehicle_dimensions['height']
        
        # ì¼ë°˜ì ìœ¼ë¡œ ì°¨ëŸ‰ ì „ë©´ì˜ ê¸°í•˜í•™ì  ì¤‘ì‹¬
        aero_center_x = length * 0.4   # ì°¨ëŸ‰ ì „ë©´ì—ì„œ 40% ì§€ì 
        aero_center_y = 0              # ì°¨ëŸ‰ ì¤‘ì‹¬ì„ 
        aero_center_z = height * 0.5   # ì°¨ëŸ‰ ë†’ì´ì˜ ì¤‘ì 
        
        return (aero_center_x, aero_center_y, aero_center_z)

# ì‚¬ìš© ì˜ˆì‹œ
physics_system = PhysicalReferencePoints(
    vehicle_mass=1500,    # 1.5í†¤
    wheelbase=2.7,        # 2.7m ì¶•ê°„ê±°ë¦¬
    track_width=1.5       # 1.5m ìœ¤ê±°
)

# ë‹¤ì–‘í•œ ë¬¼ë¦¬ì  ê¸°ì¤€ì  ê³„ì‚°
steering_angle = 15  # 15ë„ ì¡°í–¥
velocity = 50        # 50 km/h

rotation_center = physics_system.calculate_center_of_rotation(steering_angle, velocity)
instantaneous_center = physics_system.calculate_instantaneous_center(steering_angle)

suspension_config = {'front_rc_height': 0.05, 'rear_rc_height': 0.08}
roll_center = physics_system.calculate_roll_center(suspension_config)

vehicle_dims = {'length': 4.5, 'width': 1.8, 'height': 1.6}
aero_center = physics_system.calculate_aerodynamic_center(vehicle_dims)

print(f"íšŒì „ ì¤‘ì‹¬: {rotation_center}")
print(f"ìˆœê°„ íšŒì „ ì¤‘ì‹¬: {instantaneous_center}")
print(f"ë¡¤ ì„¼í„°: {roll_center}")
print(f"ê³µê¸°ì—­í•™ ì¤‘ì‹¬: {aero_center}")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
íšŒì „ ì¤‘ì‹¬: (0, 10.062, 0)
ìˆœê°„ íšŒì „ ì¤‘ì‹¬: (0, 10.062, 0)
ë¡¤ ì„¼í„°: (1.62, 0, 0.068)
ê³µê¸°ì—­í•™ ì¤‘ì‹¬: (1.8, 0, 0.8)
```

---

## 11. í†µì‹  ë° V2X ê¸°ì¤€ì ë“¤

ì°¨ëŸ‰ ê°„ í†µì‹ (V2V) ë° ì¸í”„ë¼ì™€ì˜ í†µì‹ (V2I)ì„ ìœ„í•œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import time
import json
from typing import Dict, List, Tuple

class V2XReferencePoints:
    """V2X í†µì‹ ì„ ìœ„í•œ ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_id, antenna_positions):
        self.vehicle_id = vehicle_id
        self.antenna_positions = antenna_positions
        self.communication_range = 300  # í†µì‹  ë²”ìœ„ 300m
        self.broadcast_interval = 0.1   # 100ms ì£¼ê¸°ë¡œ ìœ„ì¹˜ ì •ë³´ ì†¡ì‹ 
        
    def get_v2v_antenna_position(self):
        """ì°¨ëŸ‰ê°„ í†µì‹  ì•ˆí…Œë‚˜ ìœ„ì¹˜ ë°˜í™˜"""
        # ì¼ë°˜ì ìœ¼ë¡œ ì§€ë¶• ì¤‘ì•™ì— ì„¤ì¹˜
        return self.antenna_positions.get('v2v', (0, 0, 1.5))
    
    def get_v2i_communication_point(self):
        """ì¸í”„ë¼ í†µì‹  ê¸°ì¤€ì  ë°˜í™˜"""
        # ì‹ í˜¸ë“±, RSU(Road Side Unit)ì™€ì˜ í†µì‹ ìš©
        return self.antenna_positions.get('v2i', (-0.5, 0, 1.2))
    
    def create_broadcast_message(self, current_position, velocity, heading):
        """ìœ„ì¹˜ ì •ë³´ ì†¡ì‹  ë©”ì‹œì§€ ìƒì„±"""
        v2v_antenna_pos = self.get_v2v_antenna_position()
        
        # ì•ˆí…Œë‚˜ ìœ„ì¹˜ë¥¼ ê³ ë ¤í•œ ì‹¤ì œ ì†¡ì‹  ìœ„ì¹˜ ê³„ì‚°
        actual_broadcast_position = (
            current_position[0] + v2v_antenna_pos[0],
            current_position[1] + v2v_antenna_pos[1],
            current_position[2] + v2v_antenna_pos[2]
        )
        
        message = {
            'vehicle_id': self.vehicle_id,
            'timestamp': time.time(),
            'position': actual_broadcast_position,
            'velocity': velocity,
            'heading': heading,
            'antenna_reference': v2v_antenna_pos,
            'message_type': 'BSM'  # Basic Safety Message
        }
        
        return message
    
    def calculate_relative_position(self, other_vehicle_msg, my_position):
        """ë‹¤ë¥¸ ì°¨ëŸ‰ê³¼ì˜ ìƒëŒ€ ìœ„ì¹˜ ê³„ì‚°"""
        other_pos = other_vehicle_msg['position']
        my_antenna_pos = self.get_v2v_antenna_position()
        
        # ë‚´ ì•ˆí…Œë‚˜ ê¸°ì¤€ ì‹¤ì œ ìœ„ì¹˜
        my_actual_pos = (
            my_position[0] + my_antenna_pos[0],
            my_position[1] + my_antenna_pos[1],
            my_position[2] + my_antenna_pos[2]
        )
        
        # ìƒëŒ€ ê±°ë¦¬ ë° ë°©í–¥ ê³„ì‚°
        dx = other_pos[0] - my_actual_pos[0]
        dy = other_pos[1] - my_actual_pos[1]
        distance = (dx**2 + dy**2)**0.5
        
        return {
            'distance': distance,
            'relative_x': dx,
            'relative_y': dy,
            'is_in_range': distance <= self.communication_range
        }
    
    def process_infrastructure_message(self, rsu_message, my_position):
        """ì¸í”„ë¼ë¡œë¶€í„°ì˜ ë©”ì‹œì§€ ì²˜ë¦¬"""
        v2i_point = self.get_v2i_communication_point()
        
        # ì¸í”„ë¼ í†µì‹  ê¸°ì¤€ì ì„ ê³ ë ¤í•œ ë©”ì‹œì§€ ì²˜ë¦¬
        my_comm_position = (
            my_position[0] + v2i_point[0],
            my_position[1] + v2i_point[1],
            my_position[2] + v2i_point[2]
        )
        
        # RSUì™€ì˜ ê±°ë¦¬ ê³„ì‚°
        rsu_pos = rsu_message.get('position', (0, 0, 0))
        distance_to_rsu = ((my_comm_position[0] - rsu_pos[0])**2 + 
                          (my_comm_position[1] - rsu_pos[1])**2)**0.5
        
        return {
            'rsu_id': rsu_message.get('rsu_id'),
            'message_type': rsu_message.get('type'),
            'distance_to_rsu': distance_to_rsu,
            'signal_strength': max(0, 100 - distance_to_rsu),  # ê°„ë‹¨í•œ ì‹ í˜¸ ê°•ë„ ëª¨ë¸
            'my_comm_position': my_comm_position
        }

# ì‚¬ìš© ì˜ˆì‹œ
antenna_config = {
    'v2v': (0, 0, 1.5),      # ì§€ë¶• ì¤‘ì•™ V2V ì•ˆí…Œë‚˜
    'v2i': (-0.5, 0, 1.2)    # ì•ìª½ V2I í†µì‹  ì•ˆí…Œë‚˜
}

v2x_system = V2XReferencePoints('VEHICLE_001', antenna_config)

# í˜„ì¬ ì°¨ëŸ‰ ìƒíƒœ
my_position = (100, 50, 0)  # GPS ì¢Œí‘œ
my_velocity = 60  # km/h
my_heading = 45   # ë¶ë™ìª½ 45ë„

# ë¸Œë¡œë“œìºìŠ¤íŠ¸ ë©”ì‹œì§€ ìƒì„±
broadcast_msg = v2x_system.create_broadcast_message(my_position, my_velocity, my_heading)
print("ì†¡ì‹  ë©”ì‹œì§€:")
print(json.dumps(broadcast_msg, indent=2))

# ë‹¤ë¥¸ ì°¨ëŸ‰ìœ¼ë¡œë¶€í„° ìˆ˜ì‹ í•œ ë©”ì‹œì§€ ì²˜ë¦¬
other_vehicle_msg = {
    'vehicle_id': 'VEHICLE_002',
    'position': (150, 80, 0),
    'velocity': 55,
    'heading': 30
}

relative_info = v2x_system.calculate_relative_position(other_vehicle_msg, my_position)
print(f"\në‹¤ë¥¸ ì°¨ëŸ‰ê³¼ì˜ ìƒëŒ€ ìœ„ì¹˜: {relative_info}")

# ì¸í”„ë¼ ë©”ì‹œì§€ ì²˜ë¦¬
rsu_message = {
    'rsu_id': 'RSU_001',
    'type': 'TRAFFIC_LIGHT',
    'position': (120, 60, 3),
    'signal_phase': 'RED',
    'time_remaining': 15
}

infrastructure_info = v2x_system.process_infrastructure_message(rsu_message, my_position)
print(f"\nì¸í”„ë¼ í†µì‹  ì •ë³´: {infrastructure_info}")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
ì†¡ì‹  ë©”ì‹œì§€:
{
  "vehicle_id": "VEHICLE_001",
  "timestamp": 1719486420.123,
  "position": [100, 50, 1.5],
  "velocity": 60,
  "heading": 45,
  "antenna_reference": [0, 0, 1.5],
  "message_type": "BSM"
}

ë‹¤ë¥¸ ì°¨ëŸ‰ê³¼ì˜ ìƒëŒ€ ìœ„ì¹˜: {'distance': 58.31, 'relative_x': 50, 'relative_y': 30, 'is_in_range': True}

ì¸í”„ë¼ í†µì‹  ì •ë³´: {'rsu_id': 'RSU_001', 'message_type': 'TRAFFIC_LIGHT', 'distance_to_rsu': 22.36, 'signal_strength': 77.64, 'my_comm_position': (99.5, 50, 1.2)}
```

---

## 12. ì˜ˆì¸¡ ë° ë¯¸ë˜ ìœ„ì¹˜ ê¸°ì¤€ì ë“¤

ì°¨ëŸ‰ì˜ ë¯¸ë˜ ìœ„ì¹˜ë¥¼ ì˜ˆì¸¡í•˜ê³  ì¶©ëŒ ìœ„í—˜ì„ í‰ê°€í•˜ê¸° ìœ„í•œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple

class PredictiveReferencePoints:
    """ì˜ˆì¸¡ ë° ë¯¸ë˜ ìœ„ì¹˜ ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_dynamics):
        self.dynamics = vehicle_dynamics
        self.prediction_intervals = [1, 3, 5]  # 1ì´ˆ, 3ì´ˆ, 5ì´ˆ í›„ ì˜ˆì¸¡
        
    def predict_position_linear(self, current_pos, velocity, heading, time_horizon):
        """ì„ í˜• ìš´ë™ ëª¨ë¸ì„ ì‚¬ìš©í•œ ìœ„ì¹˜ ì˜ˆì¸¡"""
        x, y, z = current_pos
        vx = velocity * np.cos(np.radians(heading))
        vy = velocity * np.sin(np.radians(heading))
        
        # time_horizon ì´ˆ í›„ ì˜ˆìƒ ìœ„ì¹˜
        predicted_x = x + vx * time_horizon
        predicted_y = y + vy * time_horizon
        predicted_z = z  # ë†’ì´ëŠ” ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ê°€ì •
        
        return (predicted_x, predicted_y, predicted_z)
    
    def predict_position_with_acceleration(self, current_pos, velocity, heading, 
                                         acceleration, time_horizon):
        """ê°€ì†ë„ë¥¼ ê³ ë ¤í•œ ìœ„ì¹˜ ì˜ˆì¸¡"""
        x, y, z = current_pos
        vx = velocity * np.cos(np.radians(heading))
        vy = velocity * np.sin(np.radians(heading))
        ax = acceleration * np.cos(np.radians(heading))
        ay = acceleration * np.sin(np.radians(heading))
        
        # ë“±ê°€ì†ë„ ìš´ë™ ë°©ì •ì‹ ì ìš©
        predicted_x = x + vx * time_horizon + 0.5 * ax * time_horizon**2
        predicted_y = y + vy * time_horizon + 0.5 * ay * time_horizon**2
        predicted_z = z
        
        return (predicted_x, predicted_y, predicted_z)
    
    def predict_curved_trajectory(self, current_pos, velocity, heading, 
                                steering_angle, wheelbase, time_horizon):
        """ê³¡ì„  ì£¼í–‰ì„ ê³ ë ¤í•œ ê¶¤ì  ì˜ˆì¸¡"""
        if abs(steering_angle) < 0.1:  # ê±°ì˜ ì§ì§„
            return self.predict_position_linear(current_pos, velocity, heading, time_horizon)
        
        # íšŒì „ ë°˜ì§€ë¦„ ê³„ì‚°
        turn_radius = wheelbase / np.tan(np.radians(steering_angle))
        angular_velocity = velocity / turn_radius  # rad/s
        
        x, y, z = current_pos
        
        # íšŒì „ ì¤‘ì‹¬ ê³„ì‚°
        center_x = x - turn_radius * np.sin(np.radians(heading))
        center_y = y + turn_radius * np.cos(np.radians(heading))
        
        # time_horizon í›„ì˜ ê°ë„ ë³€í™”
        angle_change = angular_velocity * time_horizon
        new_heading = heading + np.degrees(angle_change)
        
        # ìƒˆë¡œìš´ ìœ„ì¹˜ ê³„ì‚°
        predicted_x = center_x + turn_radius * np.sin(np.radians(new_heading))
        predicted_y = center_y - turn_radius * np.cos(np.radians(new_heading))
        
        return (predicted_x, predicted_y, z)
    
    def calculate_collision_prediction_point(self, my_trajectory, other_trajectory):
        """ì¶©ëŒ ì˜ˆìƒ ì§€ì  ê³„ì‚°"""
        collision_points = []
        min_distance_threshold = 2.0  # 2ë¯¸í„° ì´ë‚´ ì ‘ê·¼ ì‹œ ì¶©ëŒ ìœ„í—˜
        
        for i, (my_pos, other_pos) in enumerate(zip(my_trajectory, other_trajectory)):
            distance = np.sqrt((my_pos[0] - other_pos[0])**2 + 
                             (my_pos[1] - other_pos[1])**2)
            
            if distance < min_distance_threshold:
                collision_points.append({
                    'time': i * 0.1,  # 0.1ì´ˆ ê°„ê²©ìœ¼ë¡œ ê³„ì‚°
                    'my_position': my_pos,
                    'other_position': other_pos,
                    'distance': distance,
                    'risk_level': 'HIGH' if distance < 1.0 else 'MEDIUM'
                })
        
        return collision_points
    
    def generate_trajectory_endpoints(self, current_pos, velocity, heading, 
                                    possible_maneuvers):
        """ê°€ëŠ¥í•œ ì¡°ì‘ë³„ ê¶¤ì  ëì  ìƒì„±"""
        endpoints = {}
        
        for maneuver, params in possible_maneuvers.items():
            if maneuver == 'straight':
                endpoint = self.predict_position_linear(
                    current_pos, velocity, heading, params['time']
                )
            elif maneuver == 'left_turn':
                endpoint = self.predict_curved_trajectory(
                    current_pos, velocity, heading, 
                    -params['steering_angle'], params['wheelbase'], params['time']
                )
            elif maneuver == 'right_turn':
                endpoint = self.predict_curved_trajectory(
                    current_pos, velocity, heading, 
                    params['steering_angle'], params['wheelbase'], params['time']
                )
            elif maneuver == 'emergency_brake':
                # ê¸‰ì œë™ ì‹œë‚˜ë¦¬ì˜¤
                decel_time = velocity / params['deceleration']  # ì™„ì „ ì •ì§€ ì‹œê°„
                actual_time = min(params['time'], decel_time)
                
                # ë“±ê°ì†ë„ ìš´ë™
                distance = velocity * actual_time - 0.5 * params['deceleration'] * actual_time**2
                endpoint_x = current_pos[0] + distance * np.cos(np.radians(heading))
                endpoint_y = current_pos[1] + distance * np.sin(np.radians(heading))
                endpoint = (endpoint_x, endpoint_y, current_pos[2])
            
            endpoints[maneuver] = endpoint
        
        return endpoints

# ì‚¬ìš© ì˜ˆì‹œ
vehicle_dynamics = {'wheelbase': 2.7, 'max_acceleration': 3.0, 'max_deceleration': 8.0}
predictor = PredictiveReferencePoints(vehicle_dynamics)

# í˜„ì¬ ì°¨ëŸ‰ ìƒíƒœ
current_position = (0, 0, 0)
current_velocity = 50  # km/hë¥¼ m/së¡œ ë³€í™˜: 50/3.6 â‰ˆ 13.89 m/s
current_heading = 0    # ë¶ìª½ ë°©í–¥
steering_angle = 10    # 10ë„ ì¢ŒíšŒì „

# ë‹¤ì–‘í•œ ì‹œê°„ êµ¬ê°„ë³„ ìœ„ì¹˜ ì˜ˆì¸¡
print("=== ìœ„ì¹˜ ì˜ˆì¸¡ ê²°ê³¼ ===")
for time_horizon in [1, 3, 5]:
    # ì„ í˜• ì˜ˆì¸¡
    linear_pred = predictor.predict_position_linear(
        current_position, current_velocity/3.6, current_heading, time_horizon
    )
    
    # ê³¡ì„  ì£¼í–‰ ì˜ˆì¸¡
    curved_pred = predictor.predict_curved_trajectory(
        current_position, current_velocity/3.6, current_heading, 
        steering_angle, vehicle_dynamics['wheelbase'], time_horizon
    )
    
    print(f"{time_horizon}ì´ˆ í›„:")
    print(f"  ì§ì§„ ì˜ˆì¸¡: ({linear_pred[0]:.2f}, {linear_pred[1]:.2f})")
    print(f"  ê³¡ì„  ì˜ˆì¸¡: ({curved_pred[0]:.2f}, {curved_pred[1]:.2f})")

# ê°€ëŠ¥í•œ ì¡°ì‘ë³„ ê¶¤ì  ëì  ê³„ì‚°
possible_maneuvers = {
    'straight': {'time': 3},
    'left_turn': {'steering_angle': 15, 'wheelbase': 2.7, 'time': 3},
    'right_turn': {'steering_angle': 15, 'wheelbase': 2.7, 'time': 3},
    'emergency_brake': {'deceleration': 8.0, 'time': 3}
}

endpoints = predictor.generate_trajectory_endpoints(
    current_position, current_velocity/3.6, current_heading, possible_maneuvers
)

print("\n=== ì¡°ì‘ë³„ ê¶¤ì  ëì  ===")
for maneuver, endpoint in endpoints.items():
    print(f"{maneuver}: ({endpoint[0]:.2f}, {endpoint[1]:.2f})")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
=== ìœ„ì¹˜ ì˜ˆì¸¡ ê²°ê³¼ ===
1ì´ˆ í›„:
  ì§ì§„ ì˜ˆì¸¡: (13.89, 0.00)
  ê³¡ì„  ì˜ˆì¸¡: (13.77, 1.78)
3ì´ˆ í›„:
  ì§ì§„ ì˜ˆì¸¡: (41.67, 0.00)
  ê³¡ì„  ì˜ˆì¸¡: (39.58, 15.35)
5ì´ˆ í›„:
  ì§ì§„ ì˜ˆì¸¡: (69.44, 0.00)
  ê³¡ì„  ì˜ˆì¸¡: (61.11, 39.58)

=== ì¡°ì‘ë³„ ê¶¤ì  ëì  ===
straight: (41.67, 0.00)
left_turn: (35.98, 18.33)
right_turn: (35.98, -18.33)
emergency_brake: (25.00, 0.00)
```

---

## 13. ë‹¤ì¤‘ ì°¨ëŸ‰ ì‹œìŠ¤í…œ ê¸°ì¤€ì ë“¤

ì—¬ëŸ¬ ì°¨ëŸ‰ì´ í˜‘ë ¥í•˜ì—¬ ì£¼í–‰í•˜ëŠ” êµ°ì§‘ ì£¼í–‰(Platooning) ì‹œìŠ¤í…œì˜ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import numpy as np
from typing import List, Dict
import uuid

class MultiVehicleReferencePoints:
    """ë‹¤ì¤‘ ì°¨ëŸ‰ ì‹œìŠ¤í…œ ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_id, vehicle_length=4.5):
        self.vehicle_id = vehicle_id
        self.vehicle_length = vehicle_length
        self.convoy_members = {}  # êµ°ì§‘ ë‚´ ì°¨ëŸ‰ë“¤
        self.formation_type = "line"  # ëŒ€í˜• ìœ í˜•: line, wedge, diamond
        
    def add_convoy_member(self, vehicle_id, position, role="follower"):
        """êµ°ì§‘ì— ì°¨ëŸ‰ ì¶”ê°€"""
        self.convoy_members[vehicle_id] = {
            'position': position,
            'role': role,  # leader, follower
            'join_time': 0,
            'status': 'active'
        }
    
    def calculate_formation_reference(self, leader_position, formation_index):
        """ëŒ€í˜• ê¸°ì¤€ì  ê³„ì‚°"""
        leader_x, leader_y, leader_z = leader_position
        
        if self.formation_type == "line":
            # ì¼ë ¬ ëŒ€í˜• - ì°¨ëŸ‰ë“¤ì´ ì¼ì§ì„ ìœ¼ë¡œ ë°°ì—´
            target_x = leader_x - (formation_index + 1) * (self.vehicle_length + 2.0)
            target_y = leader_y
            target_z = leader_z
            
        elif self.formation_type == "wedge":
            # ìê¸° ëŒ€í˜• - Vì í˜•íƒœë¡œ ë°°ì—´
            lateral_offset = (formation_index + 1) * 3.5  # ì°¨ì„  í­ë§Œí¼ ì˜†ìœ¼ë¡œ
            longitudinal_offset = (formation_index + 1) * 10.0
            
            side = 1 if formation_index % 2 == 0 else -1  # ì¢Œìš° êµëŒ€ ë°°ì¹˜
            target_x = leader_x - longitudinal_offset
            target_y = leader_y + side * lateral_offset
            target_z = leader_z
            
        elif self.formation_type == "diamond":
            # ë‹¤ì´ì•„ëª¬ë“œ ëŒ€í˜• - ë§ˆë¦„ëª¨ í˜•íƒœë¡œ ë°°ì—´
            if formation_index == 0:  # ì²« ë²ˆì§¸ ì¶”ì¢… ì°¨ëŸ‰
                target_x = leader_x - 15.0
                target_y = leader_y
            elif formation_index == 1:  # ì™¼ìª½ ì°¨ëŸ‰
                target_x = leader_x - 7.5
                target_y = leader_y - 3.5
            elif formation_index == 2:  # ì˜¤ë¥¸ìª½ ì°¨ëŸ‰
                target_x = leader_x - 7.5
                target_y = leader_y + 3.5
            else:  # ì¶”ê°€ ì°¨ëŸ‰ë“¤ì€ ë’¤ìª½ì— ì¼ë ¬ë¡œ
                target_x = leader_x - 25.0 - (formation_index - 3) * 12.0
                target_y = leader_y
            
            target_z = leader_z
        
        return (target_x, target_y, target_z)
    
    def calculate_leader_follower_gap(self, leader_pos, follower_pos, desired_time_gap=2.0):
        """ì„ ë‘-í›„ì† ì°¨ëŸ‰ ê°„ê²© ê³„ì‚° ë° ê´€ë¦¬"""
        # í˜„ì¬ ê±°ë¦¬ ê³„ì‚°
        current_distance = np.sqrt((leader_pos[0] - follower_pos[0])**2 + 
                                 (leader_pos[1] - follower_pos[1])**2)
        
        # ì†ë„ ê¸°ë°˜ ì•ˆì „ ê±°ë¦¬ ê³„ì‚° (ì‹œê°„ ê°„ê²© ê¸°ë°˜)
        leader_velocity = 60 / 3.6  # 60 km/hë¥¼ m/së¡œ ë³€í™˜
        desired_distance = leader_velocity * desired_time_gap + self.vehicle_length
        
        gap_status = {
            'current_distance': current_distance,
            'desired_distance': desired_distance,
            'gap_error': current_distance - desired_distance,
            'time_gap': current_distance / leader_velocity if leader_velocity > 0 else float('inf'),
            'safety_status': 'SAFE' if current_distance >= desired_distance else 'TOO_CLOSE'
        }
        
        return gap_status
    
    def calculate_convoy_center(self):
        """ì°¨ëŸ‰ êµ°ì§‘ì˜ ì¤‘ì‹¬ì  ê³„ì‚°"""
        if not self.convoy_members:
            return None
        
        positions = [member['position'] for member in self.convoy_members.values()]
        positions = np.array(positions)
        
        center_x = np.mean(positions[:, 0])
        center_y = np.mean(positions[:, 1])
        center_z = np.mean(positions[:, 2])
        
        # êµ°ì§‘ì˜ í¬ê¸°(ë°˜ê²½) ê³„ì‚°
        distances = [np.sqrt((pos[0] - center_x)**2 + (pos[1] - center_y)**2) 
                    for pos in positions]
        convoy_radius = max(distances) if distances else 0
        
        return {
            'center': (center_x, center_y, center_z),
            'radius': convoy_radius,
            'vehicle_count': len(self.convoy_members)
        }
    
    def manage_convoy_coordination(self, my_position, leader_position):
        """êµ°ì§‘ ì£¼í–‰ í˜‘ì¡° ì œì–´"""
        # ë‚´ ìœ„ì¹˜ì—ì„œ ëŒ€í˜• ê¸°ì¤€ì ê¹Œì§€ì˜ ì˜¤ì°¨ ê³„ì‚°
        my_formation_index = list(self.convoy_members.keys()).index(self.vehicle_id) \
                            if self.vehicle_id in self.convoy_members else 0
        
        target_position = self.calculate_formation_reference(leader_position, my_formation_index)
        
        # ìœ„ì¹˜ ì˜¤ì°¨ ê³„ì‚°
        position_error = {
            'longitudinal': my_position[0] - target_position[0],  # ì „í›„ ë°©í–¥
            'lateral': my_position[1] - target_position[1],       # ì¢Œìš° ë°©í–¥
            'total_error': np.sqrt((my_position[0] - target_position[0])**2 + 
                                 (my_position[1] - target_position[1])**2)
        }
        
        # ì œì–´ ëª…ë ¹ ìƒì„±
        control_action = {
            'throttle_adjustment': -0.1 if position_error['longitudinal'] > 1.0 else 0.1,
            'steering_adjustment': -0.05 * position_error['lateral'],
            'target_position': target_position,
            'formation_status': 'IN_FORMATION' if position_error['total_error'] < 2.0 else 'ADJUSTING'
        }
        
        return control_action

# ì‚¬ìš© ì˜ˆì‹œ
# êµ°ì§‘ ì£¼í–‰ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
leader_vehicle = MultiVehicleReferencePoints("LEADER_001")
follower1 = MultiVehicleReferencePoints("FOLLOWER_001")
follower2 = MultiVehicleReferencePoints("FOLLOWER_002")

# êµ°ì§‘ êµ¬ì„±
leader_position = (100, 50, 0)
follower1_position = (85, 50, 0)
follower2_position = (70, 50, 0)

# ì„ ë‘ ì°¨ëŸ‰ì— ì¶”ì¢… ì°¨ëŸ‰ë“¤ ë“±ë¡
leader_vehicle.add_convoy_member("FOLLOWER_001", follower1_position, "follower")
leader_vehicle.add_convoy_member("FOLLOWER_002", follower2_position, "follower")

# ëŒ€í˜• ë³€ê²½ (ìê¸°í˜•ìœ¼ë¡œ)
leader_vehicle.formation_type = "wedge"

print("=== êµ°ì§‘ ì£¼í–‰ ì‹œìŠ¤í…œ ===")

# ê° ì¶”ì¢… ì°¨ëŸ‰ì˜ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
for i, (vehicle_id, member_info) in enumerate(leader_vehicle.convoy_members.items()):
    target_pos = leader_vehicle.calculate_formation_reference(leader_position, i)
    print(f"{vehicle_id} ëª©í‘œ ìœ„ì¹˜: ({target_pos[0]:.2f}, {target_pos[1]:.2f})")

# ì°¨ê°„ ê±°ë¦¬ ë¶„ì„
gap_analysis = leader_vehicle.calculate_leader_follower_gap(
    leader_position, follower1_position, desired_time_gap=2.0
)
print(f"\nì°¨ê°„ ê±°ë¦¬ ë¶„ì„: {gap_analysis}")

# êµ°ì§‘ ì¤‘ì‹¬ ê³„ì‚°
convoy_center = leader_vehicle.calculate_convoy_center()
print(f"\nêµ°ì§‘ ì¤‘ì‹¬: {convoy_center}")

# ì¶”ì¢… ì°¨ëŸ‰ì˜ ì œì–´ ëª…ë ¹ ìƒì„±
follower1.convoy_members = {follower1.vehicle_id: {'position': follower1_position, 'role': 'follower'}}
control_command = follower1.manage_convoy_coordination(follower1_position, leader_position)
print(f"\nì¶”ì¢… ì°¨ëŸ‰ ì œì–´ ëª…ë ¹: {control_command}")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
=== êµ°ì§‘ ì£¼í–‰ ì‹œìŠ¤í…œ ===
FOLLOWER_001 ëª©í‘œ ìœ„ì¹˜: (90.00, 53.50)
FOLLOWER_002 ëª©í‘œ ìœ„ì¹˜: (80.00, -56.50)

ì°¨ê°„ ê±°ë¦¬ ë¶„ì„: {'current_distance': 15.0, 'desired_distance': 37.78, 'gap_error': -22.78, 'time_gap': 0.9, 'safety_status': 'TOO_CLOSE'}

êµ°ì§‘ ì¤‘ì‹¬: {'center': (85.0, 50.0, 0.0), 'radius': 15.0, 'vehicle_count': 2}

ì¶”ì¢… ì°¨ëŸ‰ ì œì–´ ëª…ë ¹: {'throttle_adjustment': 0.1, 'steering_adjustment': 0.0, 'target_position': (90.0, 53.5, 0), 'formation_status': 'ADJUSTING'}
```

---

## 14. í™˜ê²½ ì¸ì‹ ê¸°ì¤€ì ë“¤

ë‚ ì”¨, ê°€ì‹œê±°ë¦¬ ë“± ì£¼ë³€ í™˜ê²½ì„ ì¸ì‹í•˜ê¸° ìœ„í•œ ì„¼ì„œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import random
import math
from enum import Enum

class WeatherCondition(Enum):
    CLEAR = "ë§‘ìŒ"
    RAIN = "ë¹„"
    SNOW = "ëˆˆ"
    FOG = "ì•ˆê°œ"
    HEAVY_RAIN = "í­ìš°"

class EnvironmentalReferencePoints:
    """í™˜ê²½ ì¸ì‹ì„ ìœ„í•œ ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_config):
        self.vehicle_config = vehicle_config
        self.sensor_positions = self._define_sensor_positions()
        self.environmental_thresholds = self._define_thresholds()
        
    def _define_sensor_positions(self):
        """í™˜ê²½ ì„¼ì„œ ìœ„ì¹˜ ì •ì˜"""
        return {
            'rain_sensor': (0, 0, 1.4),           # ì•ìœ ë¦¬ ìƒë‹¨
            'temperature_sensor': (-2.0, 0, 0.5), # ë’·ë²”í¼ ê·¼ì²˜ (ì—”ì§„ì—´ ì˜í–¥ ìµœì†Œí™”)
            'humidity_sensor': (1.0, 0.5, 1.0),   # ì‚¬ì´ë“œë¯¸ëŸ¬ ê·¼ì²˜
            'visibility_sensor': (2.0, 0, 1.2),   # ì „ë©´ ì¹´ë©”ë¼ ìœ„ì¹˜
            'ambient_light': (0, 0, 1.5),         # ì§€ë¶• ì¤‘ì•™
            'wind_sensor': (0, 0, 1.6)            # ì§€ë¶• ìµœìƒë‹¨
        }
    
    def _define_thresholds(self):
        """í™˜ê²½ ì¡°ê±´ë³„ ì„ê³„ê°’ ì •ì˜"""
        return {
            'visibility': {
                'excellent': 1000,  # 1km ì´ìƒ
                'good': 500,        # 500m ì´ìƒ
                'moderate': 200,    # 200m ì´ìƒ
                'poor': 50,         # 50m ì´ìƒ
                'very_poor': 10     # 10m ì´ìƒ
            },
            'rain_intensity': {
                'none': 0,
                'light': 2.5,       # mm/h
                'moderate': 7.6,    # mm/h
                'heavy': 50,        # mm/h
                'very_heavy': 100   # mm/h
            },
            'temperature': {
                'freezing': 0,      # ê²°ë¹™ ìœ„í—˜
                'cold': 5,          # íƒ€ì´ì–´ ì„±ëŠ¥ ì €í•˜
                'optimal': 20,      # ìµœì  ì¡°ê±´
                'hot': 35           # ê³¼ì—´ ìœ„í—˜
            }
        }
    
    def measure_rain_intensity(self, sensor_data):
        """ë¹—ë¬¼ ê°ì§€ ì„¼ì„œë¥¼ í†µí•œ ê°•ìˆ˜ëŸ‰ ì¸¡ì •"""
        rain_sensor_pos = self.sensor_positions['rain_sensor']
        
        # ì„¼ì„œ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” í•˜ë“œì›¨ì–´ì—ì„œ ë°›ì•„ì˜´)
        raw_sensor_value = sensor_data.get('rain_sensor', 0)
        
        # ì„¼ì„œ ê°’ì„ ê°•ìˆ˜ëŸ‰(mm/h)ìœ¼ë¡œ ë³€í™˜
        rain_intensity = raw_sensor_value * 0.1  # ë³€í™˜ ê³„ìˆ˜
        
        # ê°•ìˆ˜ ë“±ê¸‰ ë¶„ë¥˜
        if rain_intensity <= self.environmental_thresholds['rain_intensity']['none']:
            rain_level = "ì—†ìŒ"
        elif rain_intensity <= self.environmental_thresholds['rain_intensity']['light']:
            rain_level = "ì•½í•œ ë¹„"
        elif rain_intensity <= self.environmental_thresholds['rain_intensity']['moderate']:
            rain_level = "ë³´í†µ ë¹„"
        elif rain_intensity <= self.environmental_thresholds['rain_intensity']['heavy']:
            rain_level = "ê°•í•œ ë¹„"
        else:
            rain_level = "ë§¤ìš° ê°•í•œ ë¹„"
        
        return {
            'sensor_position': rain_sensor_pos,
            'intensity_mmh': rain_intensity,
            'level': rain_level,
            'wiper_recommendation': rain_intensity > 1.0,
            'speed_reduction_factor': max(0.7, 1.0 - rain_intensity / 100)
        }
    
    def measure_visibility_distance(self, weather_condition, time_of_day="day"):
        """ê°€ì‹œê±°ë¦¬ ì¸¡ì • ë° ë¶„ì„"""
        visibility_sensor_pos = self.sensor_positions['visibility_sensor']
        
        # ê¸°ë³¸ ê°€ì‹œê±°ë¦¬ (ë‚ ì”¨ë³„)
        base_visibility = {
            WeatherCondition.CLEAR: 2000,
            WeatherCondition.RAIN: 800,
            WeatherCondition.SNOW: 400,
            WeatherCondition.FOG: 100,
            WeatherCondition.HEAVY_RAIN: 200
        }
        
        visibility = base_visibility.get(weather_condition, 1000)
        
        # ì‹œê°„ëŒ€ ë³´ì • (ì•¼ê°„ì—ëŠ” ê°€ì‹œê±°ë¦¬ ê°ì†Œ)
        if time_of_day == "night":
            visibility *= 0.6
        elif time_of_day == "dawn" or time_of_day == "dusk":
            visibility *= 0.8
        
        # ê°€ì‹œê±°ë¦¬ ë“±ê¸‰ ë¶„ë¥˜
        thresholds = self.environmental_thresholds['visibility']
        if visibility >= thresholds['excellent']:
            visibility_grade = "ë§¤ìš° ì¢‹ìŒ"
        elif visibility >= thresholds['good']:
            visibility_grade = "ì¢‹ìŒ"
        elif visibility >= thresholds['moderate']:
            visibility_grade = "ë³´í†µ"
        elif visibility >= thresholds['poor']:
            visibility_grade = "ë‚˜ì¨"
        else:
            visibility_grade = "ë§¤ìš° ë‚˜ì¨"
        
        return {
            'sensor_position': visibility_sensor_pos,
            'distance_m': visibility,
            'grade': visibility_grade,
            'headlight_recommendation': visibility < 500,
            'max_safe_speed': min(80, visibility / 10),  # ê°€ì‹œê±°ë¦¬ì˜ 1/10 ì†ë„ ê¶Œì¥
            'following_distance_multiplier': max(1.5, 1000 / visibility)
        }
    
    def measure_temperature_conditions(self, ambient_temp):
        """ì˜¨ë„ ì¡°ê±´ ì¸¡ì • ë° ë¶„ì„"""
        temp_sensor_pos = self.sensor_positions['temperature_sensor']
        
        # ì˜¨ë„ ì¡°ê±´ ë¶„ë¥˜
        thresholds = self.environmental_thresholds['temperature']
        if ambient_temp <= thresholds['freezing']:
            temp_condition = "ê²°ë¹™ ìœ„í—˜"
            tire_grip_factor = 0.6
            brake_distance_multiplier = 1.8
        elif ambient_temp <= thresholds['cold']:
            temp_condition = "ì¶”ìœ„"
            tire_grip_factor = 0.8
            brake_distance_multiplier = 1.3
        elif ambient_temp <= thresholds['optimal']:
            temp_condition = "ìµœì "
            tire_grip_factor = 1.0
            brake_distance_multiplier = 1.0
        elif ambient_temp <= thresholds['hot']:
            temp_condition = "ë”ìœ„"
            tire_grip_factor = 0.9
            brake_distance_multiplier = 1.1
        else:
            temp_condition = "ê³¼ì—´ ìœ„í—˜"
            tire_grip_factor = 0.7
            brake_distance_multiplier = 1.4
        
        return {
            'sensor_position': temp_sensor_pos,
            'temperature_c': ambient_temp,
            'condition': temp_condition,
            'tire_grip_factor': tire_grip_factor,
            'brake_distance_multiplier': brake_distance_multiplier,
            'heating_cooling_recommendation': ambient_temp < 10 or ambient_temp > 30
        }
    
    def calculate_comprehensive_environmental_impact(self, sensor_readings):
        """ì¢…í•©ì ì¸ í™˜ê²½ ì˜í–¥ ë¶„ì„"""
        rain_data = self.measure_rain_intensity(sensor_readings)
        visibility_data = self.measure_visibility_distance(
            sensor_readings.get('weather', WeatherCondition.CLEAR),
            sensor_readings.get('time_of_day', 'day')
        )
        temp_data = self.measure_temperature_conditions(
            sensor_readings.get('temperature', 20)
        )
        
        # ì¢…í•© ì•ˆì „ ì§€ìˆ˜ ê³„ì‚° (0-1 ìŠ¤ì¼€ì¼)
        safety_factors = [
            rain_data['speed_reduction_factor'],
            min(1.0, visibility_data['distance_m'] / 1000),
            temp_data['tire_grip_factor']
        ]
        
        overall_safety_index = sum(safety_factors) / len(safety_factors)
        
        # ê¶Œì¥ ì£¼í–‰ ëª¨ë“œ ê²°ì •
        if overall_safety_index >= 0.8:
            driving_mode = "ì¼ë°˜ ì£¼í–‰"
            max_speed_limit = 100
        elif overall_safety_index >= 0.6:
            driving_mode = "ì£¼ì˜ ì£¼í–‰"
            max_speed_limit = 80
        elif overall_safety_index >= 0.4:
            driving_mode = "ì„œí–‰ ì£¼í–‰"
            max_speed_limit = 60
        else:
            driving_mode = "ê·¹ë„ ì£¼ì˜"
            max_speed_limit = 40
        
        return {
            'overall_safety_index': overall_safety_index,
            'recommended_driving_mode': driving_mode,
            'max_recommended_speed': max_speed_limit,
            'rain_analysis': rain_data,
            'visibility_analysis': visibility_data,
            'temperature_analysis': temp_data,
            'sensor_health_check': self._check_sensor_health()
        }
    
    def _check_sensor_health(self):
        """ì„¼ì„œ ìƒíƒœ ì ê²€"""
        # ì„¼ì„œë³„ ìƒíƒœ ì‹œë®¬ë ˆì´ì…˜
        sensor_health = {}
        for sensor_name, position in self.sensor_positions.items():
            # ê°„ë‹¨í•œ ìƒíƒœ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” ì§„ë‹¨ ë°ì´í„° ì‚¬ìš©)
            health_score = random.uniform(0.8, 1.0)
            status = "ì •ìƒ" if health_score > 0.9 else "ì ê²€ í•„ìš”" if health_score > 0.7 else "ê³ ì¥"
            
            sensor_health[sensor_name] = {
                'position': position,
                'health_score': health_score,
                'status': status
            }
        
        return sensor_health

# ì‚¬ìš© ì˜ˆì‹œ
vehicle_config = {'length': 4.5, 'width': 1.8, 'height': 1.6}
env_system = EnvironmentalReferencePoints(vehicle_config)

# ì„¼ì„œ ë°ì´í„° ì‹œë®¬ë ˆì´ì…˜
sensor_readings = {
    'rain_sensor': 25,  # ì„¼ì„œ ì›ì‹œê°’
    'temperature': 3,   # 3ë„ (ê²°ë¹™ ìœ„í—˜)
    'weather': WeatherCondition.RAIN,
    'time_of_day': 'night'
}

print("=== í™˜ê²½ ì¸ì‹ ì‹œìŠ¤í…œ ë¶„ì„ ===")

# ì¢…í•© í™˜ê²½ ë¶„ì„
comprehensive_analysis = env_system.calculate_comprehensive_environmental_impact(sensor_readings)

print(f"ì „ì²´ ì•ˆì „ ì§€ìˆ˜: {comprehensive_analysis['overall_safety_index']:.2f}")
print(f"ê¶Œì¥ ì£¼í–‰ ëª¨ë“œ: {comprehensive_analysis['recommended_driving_mode']}")
print(f"ìµœëŒ€ ê¶Œì¥ ì†ë„: {comprehensive_analysis['max_recommended_speed']} km/h")

print(f"\nê°•ìˆ˜ ë¶„ì„:")
rain_info = comprehensive_analysis['rain_analysis']
print(f"  ê°•ìˆ˜ëŸ‰: {rain_info['intensity_mmh']:.1f} mm/h ({rain_info['level']})")
print(f"  ì™€ì´í¼ ì‘ë™ ê¶Œì¥: {rain_info['wiper_recommendation']}")

print(f"\nê°€ì‹œê±°ë¦¬ ë¶„ì„:")
visibility_info = comprehensive_analysis['visibility_analysis']
print(f"  ê°€ì‹œê±°ë¦¬: {visibility_info['distance_m']}m ({visibility_info['grade']})")
print(f"  ì „ì¡°ë“± ì¼œê¸° ê¶Œì¥: {visibility_info['headlight_recommendation']}")

print(f"\nì˜¨ë„ ë¶„ì„:")
temp_info = comprehensive_analysis['temperature_analysis']
print(f"  ì˜¨ë„: {temp_info['temperature_c']}Â°C ({temp_info['condition']})")
print(f"  íƒ€ì´ì–´ ê·¸ë¦½ ê³„ìˆ˜: {temp_info['tire_grip_factor']}")
```

### ğŸ“Š ì‹¤í–‰ ê²°ê³¼
```
=== í™˜ê²½ ì¸ì‹ ì‹œìŠ¤í…œ ë¶„ì„ ===
ì „ì²´ ì•ˆì „ ì§€ìˆ˜: 0.52
ê¶Œì¥ ì£¼í–‰ ëª¨ë“œ: ì„œí–‰ ì£¼í–‰
ìµœëŒ€ ê¶Œì¥ ì†ë„: 60 km/h

ê°•ìˆ˜ ë¶„ì„:
  ê°•ìˆ˜ëŸ‰: 2.5 mm/h (ì•½í•œ ë¹„)
  ì™€ì´í¼ ì‘ë™ ê¶Œì¥: True

ê°€ì‹œê±°ë¦¬ ë¶„ì„:
  ê°€ì‹œê±°ë¦¬: 480m (ë³´í†µ)
  ì „ì¡°ë“± ì¼œê¸° ê¶Œì¥: True

ì˜¨ë„ ë¶„ì„:
  ì˜¨ë„: 3Â°C (ê²°ë¹™ ìœ„í—˜)
  íƒ€ì´ì–´ ê·¸ë¦½ ê³„ìˆ˜: 0.6
```

---

## 15. ë³´í—˜/ì‚¬ê³  ì¡°ì‚¬ ê¸°ì¤€ì ë“¤

ì‚¬ê³  ë°œìƒ ì‹œ ì›ì¸ ë¶„ì„ê³¼ ì±…ì„ ì†Œì¬ íŒŒì•…ì„ ìœ„í•œ ê¸°ì¤€ì ë“¤ì…ë‹ˆë‹¤.

### ğŸ”§ ì½”ë“œ ì˜ˆì‹œ

```python
import json
import hashlib
from datetime import datetime
from typing import Dict, List, Tuple

class AccidentAnalysisReferencePoints:
    """ì‚¬ê³  ë¶„ì„ ë° ë³´í—˜ ì¡°ì‚¬ìš© ê¸°ì¤€ì  ê´€ë¦¬ í´ë˜ìŠ¤"""
    
    def __init__(self, vehicle_id, insurance_policy):
        self.vehicle_id = vehicle_id
        self.insurance_policy = insurance_policy
        self.black_box_data = []
        self.impact_points = self._define_impact_measurement_points()
        
    def _define_impact_measurement_points(self):
        """ì¶©ëŒ ì¸¡ì • ê¸°ì¤€ì ë“¤ ì •ì˜"""
        return {
            'front_impact_center': (2.25, 0, 0.8),      # ì „ë©´ ì¶©ëŒ ì¤‘ì‹¬ì 
            'rear_impact_center': (-2.25, 0, 0.8),      # í›„ë©´ ì¶©ëŒ ì¤‘ì‹¬ì 
            'left_side_impact': (0, 0.9, 0.8),          # ì¢Œì¸¡ ì¶©ëŒì 
            'right_side_impact': (0, -0.9, 0.8),        # ìš°ì¸¡ ì¶©ëŒì 
            'rollover_reference': (0, 0, 1.2),          # ì „ë³µ ê¸°ì¤€ì 
            'crumple_zone_front': (1.8, 0, 0.5),        # ì „ë°© í¬ëŸ¼í”Œ ì¡´
            'crumple_zone_rear': (-1.8, 0, 0.5),        # í›„ë°© í¬ëŸ¼í”Œ ì¡´
            'occupant_protection_zone': (0, 0, 1.0)     # ìŠ¹ê° ë³´í˜¸ êµ¬ì—­
        }
    
    def record_pre_accident_data(self, vehicle_state, environmental_conditions):
        """ì‚¬ê³  ì „ ë°ì´í„° ê¸°ë¡"""
        timestamp = datetime.now().isoformat()
        
        pre_accident_record = {
            'timestamp': timestamp,
            'vehicle_position': vehicle_state['position'],
            'velocity': vehicle_state['velocity'],
            'acceleration': vehicle_state.get('acceleration', 0),
            'steering_angle': vehicle_state.get('steering_angle', 0),
            'brake_status': vehicle_state.get('brake_applied', False),
            'throttle_position': vehicle_state.get('throttle', 0),
            'environmental_conditions': environmental_conditions,
            'data_hash': self._generate_data_hash(vehicle_state, environmental_conditions)
        }
        
        self.black_box_data.append(pre_accident_record)
        
        # ìµœê·¼ 30ì´ˆ ë°ì´í„°ë§Œ ìœ ì§€ (ë©”ëª¨ë¦¬ ê´€ë¦¬)
        if len(self.black_box_data) > 300:  # 10Hz ê¸°ì¤€ 30ì´ˆ
            self.black_box_data.pop(0)
        
        return pre_accident_record
    
    def analyze_accident_reconstruction(self, impact_data, final_positions):
        """ì‚¬ê³  ì¬í˜„ ë¶„ì„"""
        impact_point = impact_data['impact_location']
        impact_force = impact_data['impact_magnitude']
        impact_angle = impact_data['impact_angle']
        
        # ì¶©ëŒ ìœ í˜• ë¶„ì„
        collision_type = self._determine_collision_type(impact_point, impact_angle)
        
        # ì¶©ëŒ ì†ë„ ì—­ì‚° (ì—ë„ˆì§€ ë³´ì¡´ ë²•ì¹™ ì ìš©)
        estimated_impact_speed = self._estimate_impact_speed(
            impact_force, collision_type, final_positions
        )
        
        # ì±…ì„ ì†Œì¬ ì´ˆê¸° ë¶„ì„
        liability_factors = self._analyze_liability_factors(
            self.black_box_data[-10:],  # ì‚¬ê³  ì§ì „ 1ì´ˆ ë°ì´í„°
            collision_type,
            impact_angle
        )
        
        reconstruction_report = {
            'accident_id': hashlib.md5(f"{self.vehicle_id}_{datetime.now()}".encode()).hexdigest(),
            'collision_type': collision_type,
            'impact_location': impact_point,
            'estimated_impact_speed': estimated_impact_speed,
            'collision_angle': impact_angle,
            'pre_accident_trajectory': self._calculate_pre_accident_trajectory(),
            'liability_analysis': liability_factors,
            'damage_assessment': self._assess_vehicle_damage(impact_point, impact_force),
            'evidence_preservation': self._preserve_digital_evidence()
        }
        
        return reconstruction_report
    
    def _determine_collision_type(self, impact_point, impact_angle):
        """ì¶©ëŒ ìœ í˜• ê²°ì •"""
        x, y, z = impact_point
        
        if abs(y) < 0.5:  # ì „í›„ë°© ì¶©ëŒ
            if x > 0:
                return "ì •ë©´ ì¶©ëŒ"
            else:
                return "í›„ë©´ ì¶”ëŒ"
        elif abs(x) < 1.0:  # ì¸¡ë©´ ì¶©ëŒ
            if y > 0:
                return "ì¢Œì¸¡ë©´ ì¶©ëŒ"
            else:
                return "ìš°ì¸¡ë©´ ì¶©ëŒ"
        elif impact_angle > 30:
            return "ê°ë„ ì¶©ëŒ"
        else:
            return "ì ‘ì´‰ ì‚¬ê³ "
    
    def _estimate_impact_speed(self, impact_force, collision_type, final_positions):
        """ì¶©ëŒ ì†ë„ ì¶”ì •"""
        # ê°„ë‹¨í•œ ì¶©ëŒ ì—­í•™ ëª¨ë¸ (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ê³„ì‚° í•„ìš”)
        base_speed_factor = {
            "ì •ë©´ ì¶©ëŒ": 1.2,
            "í›„ë©´ ì¶”ëŒ": 0.8,
            "ì¢Œì¸¡ë©´ ì¶©ëŒ": 1.0,
            "ìš°ì¸¡ë©´ ì¶©ëŒ": 1.0,
            "ê°ë„ ì¶©ëŒ": 0.9,
            "ì ‘ì´‰ ì‚¬ê³ ": 0.3
        }
        
        factor = base_speed_factor.get(collision_type, 1.0)
        estimated_speed = (impact_force / 1000) * factor * 10  # ë‹¨ìˆœí™”ëœ ê³„ì‚°
        
        return min(estimated_speed, 200)  # í˜„ì‹¤ì ì¸ ìµœëŒ€ê°’ ì œí•œ
    
    def _analyze_liability_factors(self, recent_data, collision_type, impact_angle):
        """ì±…ì„ ì†Œì¬ ë¶„ì„ ìš”ì†Œë“¤"""
        if not recent_data:
            return {'analysis': 'ë°ì´í„° ë¶€ì¡±', 'confidence': 0}
        
        last_record = recent_data[-1]
        
        liability_factors = {
            'speed_compliance': self._check_speed_compliance(last_record),
            'brake_application': last_record.get('brake_status', False),
            'steering_input': abs(last_record.get('steering_angle', 0)) > 5,
            'environmental_factors': last_record.get('environmental_conditions', {}),
            'traffic_violation_indicators': self._check_traffic_violations(recent_data),
            'evasive_action_taken': self._detect_evasive_actions(recent_data)
        }
        
        # ê°„ë‹¨í•œ ì±…ì„ë„ ê³„ì‚° (ì‹¤ì œë¡œëŠ” ì „ë¬¸ê°€ ì‹œìŠ¤í…œ í•„ìš”)
        responsibility_score = 0.


# ğŸš— NumPy ììœ¨ì£¼í–‰ ì™„ë²½ ê°€ì´ë“œ

## ğŸ“Œ ëª©ì°¨
- [ì†Œê°œ](#-ì†Œê°œ)
- [í™˜ê²½ ì„¤ì •](#-í™˜ê²½-ì„¤ì •)
- [ê¸°ë³¸ ì‚¬ìš©ë²•](#1-numpy-ê¸°ë³¸-ì‚¬ìš©ë²•)
- [ì¸ë±ì‹± & ìŠ¬ë¼ì´ì‹±](#2-ë°°ì—´-ì¸ë±ì‹±--ìŠ¬ë¼ì´ì‹±)
- [ë°°ì—´ ì—°ì‚°](#3-ë°°ì—´-ì—°ì‚°)
- [í˜•íƒœ ë³€ê²½ & í†µê³„](#4-ë°°ì—´-í˜•íƒœ-ë³€ê²½--í†µê³„-í•¨ìˆ˜)
- [ììœ¨ì£¼í–‰ ì‹¤ì „ ì˜ˆì œ](#5-ììœ¨ì£¼í–‰-ì‹¤ì „-ì˜ˆì œ)
- [ë§ˆë¬´ë¦¬](#-ë§ˆë¬´ë¦¬)

---

## ğŸ¯ ì†Œê°œ

**NumPy**ëŠ” ììœ¨ì£¼í–‰ ì‹œìŠ¤í…œ ê°œë°œì— **í•„ìˆ˜ì ì¸ ë¼ì´ë¸ŒëŸ¬ë¦¬**ì…ë‹ˆë‹¤. 

### ì™œ ììœ¨ì£¼í–‰ì—ì„œ NumPyê°€ ì¤‘ìš”í•œê°€ìš”?
- ğŸ“¡ **ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬**: LiDAR, ì¹´ë©”ë¼, IMU ë“±ì˜ ëŒ€ìš©ëŸ‰ ë°ì´í„°
- ğŸ§® **ìˆ˜í•™ì  ì—°ì‚°**: ì¢Œí‘œ ë³€í™˜, íšŒì „ í–‰ë ¬, ë²¡í„° ì—°ì‚°
- ğŸ–¼ï¸ **ì´ë¯¸ì§€ ì²˜ë¦¬**: í”½ì…€ ë°ì´í„° ì¡°ì‘ ë° í•„í„°ë§
- âš¡ **ì„±ëŠ¥ ìµœì í™”**: ìˆœìˆ˜ Python ëŒ€ë¹„ ìµœëŒ€ 100ë°° ë¹ ë¥¸ ì—°ì‚°

---

## ğŸ›  í™˜ê²½ ì„¤ì •

```bash
# NumPy ì„¤ì¹˜
pip install numpy

# ì¶”ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ (ì‹œê°í™”ìš©)
pip install matplotlib opencv-python
```

---

## 1. NumPy ê¸°ë³¸ ì‚¬ìš©ë²•

### 1.1 ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„í¬íŠ¸ ë° ë°°ì—´ ìƒì„±

```python
import numpy as np

# ğŸ”§ ê¸°ë³¸ ë°°ì—´ ìƒì„±
# 1ì°¨ì›: ì°¨ëŸ‰ ì†ë„ ë°ì´í„°
vehicle_speed = np.array([30, 45, 60, 55, 40])  # km/h
print(f"ì°¨ëŸ‰ ì†ë„: {vehicle_speed}")
print(f"ë°°ì—´ í˜•íƒœ: {vehicle_speed.shape}")  # (5,)

# 2ì°¨ì›: 3D í¬ì¸íŠ¸ í´ë¼ìš°ë“œ (x, y, z ì¢Œí‘œ)
lidar_points = np.array([
    [1.2, 0.5, 0.1],  # í¬ì¸íŠ¸ 1
    [2.3, -1.0, 0.2], # í¬ì¸íŠ¸ 2
    [0.8, 2.1, 0.0]   # í¬ì¸íŠ¸ 3
])
print(f"LiDAR í¬ì¸íŠ¸:\n{lidar_points}")
print(f"í¬ì¸íŠ¸ ê°œìˆ˜: {lidar_points.shape[0]}, ì¢Œí‘œ ì°¨ì›: {lidar_points.shape[1]}")
```

### 1.2 íŠ¹ìˆ˜ ë°°ì—´ ìƒì„±

```python
# ğŸ–¼ï¸ ë¹ˆ ì´ë¯¸ì§€ ìƒì„± (640x480, í‘ë°±)
empty_image = np.zeros((480, 640))
print(f"ë¹ˆ ì´ë¯¸ì§€ í¬ê¸°: {empty_image.shape}")

# ğŸ¯ ë‹¨ìœ„ í–‰ë ¬ (íšŒì „ í–‰ë ¬ ì´ˆê¸°í™”ìš©)
identity_matrix = np.eye(3)
print(f"3x3 ë‹¨ìœ„ í–‰ë ¬:\n{identity_matrix}")

# ğŸ“Š ê· ë“± ë¶„í¬ ë°ì´í„° ìƒì„±
time_stamps = np.linspace(0, 10, 100)  # 0~10ì´ˆ, 100ê°œ ìƒ˜í”Œ
print(f"ì‹œê°„ ìƒ˜í”Œ: {time_stamps[:5]}...")  # ì²˜ìŒ 5ê°œë§Œ ì¶œë ¥
```

### 1.3 ë°ì´í„° íƒ€ì… ê´€ë¦¬

```python
# ğŸ“ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° íƒ€ì… ì„ íƒ
gps_coordinates = np.array([37.5665, 126.9780], dtype=np.float32)  # ìœ„ë„, ê²½ë„
sensor_readings = np.array([1, 0, 1, 1, 0], dtype=np.bool_)       # ì„¼ì„œ on/off

print(f"GPS ì¢Œí‘œ: {gps_coordinates} (íƒ€ì…: {gps_coordinates.dtype})")
print(f"ì„¼ì„œ ìƒíƒœ: {sensor_readings} (íƒ€ì…: {sensor_readings.dtype})")
```

---

## 2. ë°°ì—´ ì¸ë±ì‹± & ìŠ¬ë¼ì´ì‹±

### 2.1 ê¸°ë³¸ ì¸ë±ì‹±

```python
# ğŸ–¼ï¸ ì¹´ë©”ë¼ ì´ë¯¸ì§€ ì‹œë®¬ë ˆì´ì…˜ (ê°„ë‹¨í•œ 4x4 í”½ì…€)
camera_image = np.array([
    [10,  20,  30,  40 ],
    [50,  60,  70,  80 ],
    [90,  100, 110, 120],
    [130, 140, 150, 160]
])

print("ì¹´ë©”ë¼ ì´ë¯¸ì§€:")
print(camera_image)

# ğŸ¯ íŠ¹ì • í”½ì…€ ê°’ ì ‘ê·¼
print(f"ì¢Œìƒë‹¨ í”½ì…€: {camera_image[0, 0]}")
print(f"ìš°í•˜ë‹¨ í”½ì…€: {camera_image[3, 3]}")
```

### 2.2 ìŠ¬ë¼ì´ì‹±ìœ¼ë¡œ ROI ì¶”ì¶œ

```python
# ğŸ” ê´€ì‹¬ ì˜ì—­(ROI) ì¶”ì¶œ
# ì˜ˆ: ë„ë¡œ í‘œì§€íŒì´ ìˆëŠ” ì¤‘ì•™ ì˜ì—­
roi = camera_image[1:3, 1:3]  # 2x2 ì¤‘ì•™ ì˜ì—­
print(f"ê´€ì‹¬ ì˜ì—­ (ROI):\n{roi}")

# ğŸ“Š ì²« ë²ˆì§¸ í–‰ ì „ì²´ (ìˆ˜í‰ì„  ê²€ì¶œìš©)
horizon_line = camera_image[0, :]
print(f"ìˆ˜í‰ì„  í”½ì…€: {horizon_line}")

# ğŸ“Š ë§ˆì§€ë§‰ ì—´ ì „ì²´ (ì°¨ì„  ê²€ì¶œìš©)
lane_edge = camera_image[:, -1]
print(f"ì°¨ì„  ê°€ì¥ìë¦¬: {lane_edge}")
```

### 2.3 ì¡°ê±´ë¶€ í•„í„°ë§

```python
# ğŸ”§ ë°ì€ í”½ì…€ë§Œ ì¶”ì¶œ (ì„ê³„ê°’ ê¸°ë°˜)
bright_pixels = camera_image[camera_image > 80]
print(f"ë°ì€ í”½ì…€ (>80): {bright_pixels}")

# ğŸ”§ íŠ¹ì • ë²”ìœ„ì˜ í”½ì…€ (ë…¸ì´ì¦ˆ ì œê±°)
normal_range = camera_image[(camera_image >= 50) & (camera_image <= 120)]
print(f"ì •ìƒ ë²”ìœ„ í”½ì…€ (50~120): {normal_range}")

# ğŸ“ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ìœ„ì¹˜ ì°¾ê¸°
bright_positions = np.where(camera_image > 100)
print(f"ë°ì€ í”½ì…€ ìœ„ì¹˜ (í–‰, ì—´): {list(zip(bright_positions[0], bright_positions[1]))}")
```

---

## 3. ë°°ì—´ ì—°ì‚°

### 3.1 ë²¡í„° ì—°ì‚° (ì¢Œí‘œ ë³€í™˜)

```python
# ğŸš— ì°¨ëŸ‰ ìœ„ì¹˜ ë°ì´í„°
vehicle_position = np.array([10.0, 5.0, 0.0])  # x, y, z (ë¯¸í„°)
translation_vector = np.array([2.0, -1.0, 0.5])  # ì´ë™ëŸ‰

# â• ìœ„ì¹˜ ì—…ë°ì´íŠ¸
new_position = vehicle_position + translation_vector
print(f"ì´ì „ ìœ„ì¹˜: {vehicle_position}")
print(f"ìƒˆ ìœ„ì¹˜: {new_position}")

# âœ–ï¸ ìŠ¤ì¼€ì¼ë§ (ë‹¨ìœ„ ë³€í™˜: ë¯¸í„° â†’ ì„¼í‹°ë¯¸í„°)
position_cm = vehicle_position * 100
print(f"ì„¼í‹°ë¯¸í„° ë‹¨ìœ„: {position_cm}")
```

### 3.2 í–‰ë ¬ ì—°ì‚° (íšŒì „ ë³€í™˜)

```python
# ğŸ”„ 2D íšŒì „ í–‰ë ¬ (45ë„ íšŒì „)
angle = np.pi / 4  # 45ë„ë¥¼ ë¼ë””ì•ˆìœ¼ë¡œ
rotation_matrix = np.array([
    [np.cos(angle), -np.sin(angle)],
    [np.sin(angle),  np.cos(angle)]
])

# ğŸ“ 2D í¬ì¸íŠ¸ë“¤
points_2d = np.array([
    [1, 0],    # í¬ì¸íŠ¸ 1
    [0, 1],    # í¬ì¸íŠ¸ 2
    [-1, 0]    # í¬ì¸íŠ¸ 3
])

# ğŸ”„ í¬ì¸íŠ¸ë“¤ íšŒì „
rotated_points = points_2d @ rotation_matrix
print(f"ì›ë³¸ í¬ì¸íŠ¸:\n{points_2d}")
print(f"íšŒì „ëœ í¬ì¸íŠ¸:\n{rotated_points}")
```

### 3.3 LiDAR ë°ì´í„° ì²˜ë¦¬

```python
# ğŸ“¡ LiDAR í¬ì¸íŠ¸ í´ë¼ìš°ë“œ (ê±°ë¦¬ ê¸°ë°˜ í•„í„°ë§)
lidar_distances = np.array([2.1, 15.8, 3.2, 45.6, 1.9, 25.3])  # ë¯¸í„°

# ğŸ”§ ê·¼ê±°ë¦¬ ê°ì²´ë§Œ í•„í„°ë§ (20m ì´ë‚´)
nearby_objects = lidar_distances[lidar_distances < 20.0]
print(f"ê·¼ê±°ë¦¬ ê°ì²´ ê±°ë¦¬: {nearby_objects}")

# ğŸ“Š ê±°ë¦¬ í†µê³„
print(f"í‰ê·  ê±°ë¦¬: {np.mean(lidar_distances):.2f}m")
print(f"ìµœê·¼ì ‘ ê°ì²´: {np.min(lidar_distances):.2f}m")
print(f"ìµœì›ê±°ë¦¬ ê°ì²´: {np.max(lidar_distances):.2f}m")
```

---

## 4. ë°°ì—´ í˜•íƒœ ë³€ê²½ & í†µê³„ í•¨ìˆ˜

### 4.1 í˜•íƒœ ë³€ê²½

```python
# ğŸ“Š ì„¼ì„œ ë°ì´í„° ì¬êµ¬ì„±
sensor_readings = np.arange(1, 13)  # 1~12ë²ˆ ì„¼ì„œ
print(f"1D ì„¼ì„œ ë°ì´í„°: {sensor_readings}")

# ğŸ”§ 3x4 ê·¸ë¦¬ë“œë¡œ ì¬ë°°ì¹˜
sensor_grid = sensor_readings.reshape(3, 4)
print(f"3x4 ì„¼ì„œ ê·¸ë¦¬ë“œ:\n{sensor_grid}")

# ğŸ”§ ìë™ ì°¨ì› ê³„ì‚° (-1 ì‚¬ìš©)
sensor_2col = sensor_readings.reshape(-1, 2)  # 2ì—´, í–‰ì€ ìë™ ê³„ì‚°
print(f"2ì—´ ë°°ì¹˜:\n{sensor_2col}")

# ğŸ“ 1ì°¨ì›ìœ¼ë¡œ í‰íƒ„í™”
flattened = sensor_grid.flatten()
print(f"í‰íƒ„í™”ëœ ë°ì´í„°: {flattened}")
```

### 4.2 ë¸Œë¡œë“œìºìŠ¤íŒ…

```python
# ğŸ”§ ì„¼ì„œ ë³´ì •ê°’ ì ìš©
sensor_matrix = np.array([
    [10, 20, 30],
    [40, 50, 60],
    [70, 80, 90]
])

# ê° ì—´ì— ì„œë¡œ ë‹¤ë¥¸ ë³´ì •ê°’ ì ìš©
calibration_factors = np.array([0.9, 1.0, 1.1])  # ì—´ë³„ ë³´ì •
calibrated_sensors = sensor_matrix * calibration_factors

print(f"ì›ë³¸ ì„¼ì„œê°’:\n{sensor_matrix}")
print(f"ë³´ì •ëœ ì„¼ì„œê°’:\n{calibrated_sensors}")

# ê° í–‰ì— ì˜¤í”„ì…‹ ì ìš©
row_offsets = np.array([[5], [10], [15]])  # í–‰ë³„ ì˜¤í”„ì…‹
offset_sensors = sensor_matrix + row_offsets
print(f"ì˜¤í”„ì…‹ ì ìš© ê²°ê³¼:\n{offset_sensors}")
```

### 4.3 í†µê³„ ë¶„ì„

```python
# ğŸ“Š ì£¼í–‰ ë°ì´í„° ë¶„ì„
driving_speeds = np.array([
    [30, 45, 60, 55],  # 1êµ¬ê°„ ì†ë„
    [35, 50, 65, 50],  # 2êµ¬ê°„ ì†ë„
    [25, 40, 55, 45]   # 3êµ¬ê°„ ì†ë„
])

print("êµ¬ê°„ë³„ ì£¼í–‰ ì†ë„:")
print(driving_speeds)

# ğŸ“ˆ ê¸°ë³¸ í†µê³„
print(f"ì „ì²´ í‰ê·  ì†ë„: {np.mean(driving_speeds):.1f} km/h")
print(f"ìµœê³  ì†ë„: {np.max(driving_speeds)} km/h")
print(f"ì†ë„ í‘œì¤€í¸ì°¨: {np.std(driving_speeds):.2f}")

# ğŸ“Š ì¶•ë³„ í†µê³„
print(f"êµ¬ê°„ë³„ í‰ê·  ì†ë„: {np.mean(driving_speeds, axis=1)}")  # ê° í–‰ì˜ í‰ê· 
print(f"ì‹œì ë³„ í‰ê·  ì†ë„: {np.mean(driving_speeds, axis=0)}")  # ê° ì—´ì˜ í‰ê· 

# ğŸ” ìµœê³ ì†ë„ ìœ„ì¹˜ ì°¾ê¸°
max_speed_pos = np.unravel_index(np.argmax(driving_speeds), driving_speeds.shape)
print(f"ìµœê³ ì†ë„ ìœ„ì¹˜: {max_speed_pos}êµ¬ê°„ {max_speed_pos}ë²ˆì§¸")
```

---

## 5. ììœ¨ì£¼í–‰ ì‹¤ì „ ì˜ˆì œ

### 5.1 ì¹´ë©”ë¼ ì´ë¯¸ì§€ ì²˜ë¦¬

```python
# ğŸ–¼ï¸ ê°„ë‹¨í•œ ì°¨ì„  ê²€ì¶œ ì‹œë®¬ë ˆì´ì…˜
def detect_lane_lines(image):
    """ê°„ë‹¨í•œ ì°¨ì„  ê²€ì¶œ í•¨ìˆ˜"""
    # ê°€ì¥ìë¦¬ ê²€ì¶œ (ê°„ë‹¨í•œ ë²„ì „)
    edges = np.abs(np.diff(image, axis=1))  # ìˆ˜í‰ ë°©í–¥ ë³€í™”ëŸ‰
    
    # ì„ê³„ê°’ì„ ë„˜ëŠ” ê°€ì¥ìë¦¬ë§Œ ì¶”ì¶œ
    lane_threshold = np.percentile(edges, 90)  # ìƒìœ„ 10%
    lane_candidates = edges > lane_threshold
    
    return lane_candidates

# í…ŒìŠ¤íŠ¸ ì´ë¯¸ì§€ ìƒì„±
test_image = np.random.randint(0, 256, (10, 20))  # 10x20 ëœë¤ ì´ë¯¸ì§€
lane_detection = detect_lane_lines(test_image)

print("ì°¨ì„  ê²€ì¶œ ê²°ê³¼:")
print(lane_detection.astype(int))  # True/Falseë¥¼ 1/0ìœ¼ë¡œ í‘œì‹œ
```

### 5.2 LiDAR í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ì²˜ë¦¬

```python
# ğŸ“¡ 3D í¬ì¸íŠ¸ í´ë¼ìš°ë“œ í•„í„°ë§
def filter_ground_points(points, ground_height_threshold=0.2):
    """ì§€ë©´ í¬ì¸íŠ¸ ì œê±°"""
    # Z ì¢Œí‘œê°€ ì„ê³„ê°’ë³´ë‹¤ ë†’ì€ í¬ì¸íŠ¸ë§Œ ìœ ì§€
    return points[points[:, 2] > ground_height_threshold]

def cluster_nearby_points(points, max_distance=2.0):
    """ê·¼ê±°ë¦¬ í¬ì¸íŠ¸ í´ëŸ¬ìŠ¤í„°ë§ (ê°„ë‹¨í•œ ë²„ì „)"""
    distances = np.linalg.norm(points[:, :2], axis=1)  # XY ê±°ë¦¬ë§Œ ê³„ì‚°
    return points[distances < max_distance]

# ìƒ˜í”Œ LiDAR ë°ì´í„°
lidar_cloud = np.array([
    [1.0, 2.0, 0.1],   # ì§€ë©´ ê·¼ì²˜
    [2.5, 1.5, 1.8],   # ì°¨ëŸ‰ ë†’ì´
    [10.0, 5.0, 0.05], # ì›ê±°ë¦¬ ì§€ë©´
    [1.8, -1.2, 2.1],  # ê·¼ê±°ë¦¬ ê°ì²´
    [0.5, 0.8, 1.5]    # ê·¼ê±°ë¦¬ ê°ì²´
])

# í•„í„°ë§ ë‹¨ê³„ë³„ ì ìš©
print(f"ì›ë³¸ í¬ì¸íŠ¸ ìˆ˜: {len(lidar_cloud)}")

filtered_points = filter_ground_points(lidar_cloud)
print(f"ì§€ë©´ ì œê±° í›„: {len(filtered_points)}")

nearby_points = cluster_nearby_points(filtered_points)
print(f"ê·¼ê±°ë¦¬ í•„í„°ë§ í›„: {len(nearby_points)}")
print("ìµœì¢… í¬ì¸íŠ¸ë“¤:")
print(nearby_points)
```

### 5.3 GPS ì¢Œí‘œ ë³€í™˜

```python
# ğŸ—ºï¸ GPS ì¢Œí‘œê³„ ë³€í™˜
def convert_gps_to_local(gps_points, origin_gps):
    """GPS ì¢Œí‘œë¥¼ ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜ (ë‹¨ìˆœí™”ëœ ë²„ì „)"""
    # ìœ„ë„/ê²½ë„ ì°¨ì´ë¥¼ ë¯¸í„°ë¡œ ê·¼ì‚¬ ë³€í™˜
    lat_diff = (gps_points[:, 0] - origin_gps[0]) * 111000  # ìœ„ë„ 1ë„ â‰ˆ 111km
    lon_diff = (gps_points[:, 1] - origin_gps[1]) * 111000 * np.cos(origin_gps[0] * np.pi / 180)
    
    return np.column_stack([lat_diff, lon_diff])

# GPS ì›¨ì´í¬ì¸íŠ¸
waypoints_gps = np.array([
    [37.5665, 126.9780],  # ì„œìš¸ì‹œì²­
    [37.5651, 126.9895],  # ëª…ë™
    [37.5658, 126.9769]   # ë•ìˆ˜ê¶
])

origin = waypoints_gps[0]  # ì²« ë²ˆì§¸ ì§€ì ì„ ì›ì ìœ¼ë¡œ
local_coords = convert_gps_to_local(waypoints_gps, origin)

print("GPS â†’ ë¡œì»¬ ì¢Œí‘œ ë³€í™˜:")
for i, (gps, local) in enumerate(zip(waypoints_gps, local_coords)):
    print(f"ì§€ì  {i+1}: GPS{gps} â†’ ë¡œì»¬({local[0]:.1f}, {local[1]:.1f})m")
```

---

## ğŸ’¡ ì„±ëŠ¥ ìµœì í™” íŒ

### ë²¡í„°í™” ì—°ì‚° ì‚¬ìš©
```python
# âŒ ëŠë¦° ë°©ë²• (Python ë°˜ë³µë¬¸)
def slow_distance_calculation(points):
    distances = []
    for point in points:
        dist = (point[0]**2 + point[1]**2)**0.5
        distances.append(dist)
    return distances

# âœ… ë¹ ë¥¸ ë°©ë²• (NumPy ë²¡í„°í™”)
def fast_distance_calculation(points):
    return np.linalg.norm(points, axis=1)

# ì„±ëŠ¥ ë¹„êµ ì˜ˆì œ
sample_points = np.random.randn(1000, 2)
%timeit slow_distance_calculation(sample_points)  # ëŠë¦¼
%timeit fast_distance_calculation(sample_points)  # ë¹ ë¦„
```

### ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ë°ì´í„° íƒ€ì…
```python
# ğŸ”§ ì ì ˆí•œ ë°ì´í„° íƒ€ì… ì„ íƒìœ¼ë¡œ ë©”ëª¨ë¦¬ ì ˆì•½
large_array = np.random.randint(0, 255, (1000, 1000))

# 8ë¹„íŠ¸ ì •ìˆ˜ ì‚¬ìš© (ì´ë¯¸ì§€ í”½ì…€ê°’ 0-255)
image_data = large_array.astype(np.uint8)  # ë©”ëª¨ë¦¬ 1/8 ì ˆì•½

# 32ë¹„íŠ¸ ë¶€ë™ì†Œìˆ˜ì  (ëŒ€ë¶€ë¶„ì˜ ê³„ì‚°ì— ì¶©ë¶„í•œ ì •ë°€ë„)
sensor_data = np.random.randn(1000, 3).astype(np.float32)  # ë©”ëª¨ë¦¬ 1/2 ì ˆì•½
```

---

## ğŸš¨ ì£¼ì˜ì‚¬í•­ & ë””ë²„ê¹… íŒ

### 1. ë°°ì—´ ì°¨ì› í™•ì¸
```python
# ì°¨ì› ë¶ˆì¼ì¹˜ ì˜¤ë¥˜ ë°©ì§€
def safe_matrix_multiply(A, B):
    print(f"A í˜•íƒœ: {A.shape}, B í˜•íƒœ: {B.shape}")
    if A.shape[1] != B.shape[0]:
        raise ValueError(f"í–‰ë ¬ ê³±ì…ˆ ë¶ˆê°€: {A.shape} @ {B.shape}")
    return A @ B
```

### 2. NaN/Inf ê°’ ì²˜ë¦¬
```python
# ì„¼ì„œ ë°ì´í„°ì˜ ì´ìƒê°’ ì²˜ë¦¬
def clean_sensor_data(data):
    # NaN, Inf ê°’ í™•ì¸
    if np.any(np.isnan(data)) or np.any(np.isinf(data)):
        print("âš ï¸ ì´ìƒê°’ ê°ì§€ë¨!")
        # NaNì„ 0ìœ¼ë¡œ, Infë¥¼ í° ê°’ìœ¼ë¡œ ëŒ€ì²´
        data = np.nan_to_num(data, nan=0.0, posinf=1e6, neginf=-1e6)
    return data
```

---

## ğŸ“š ì¶”ê°€ í•™ìŠµ ìë£Œ

### ê´€ë ¨ ë¼ì´ë¸ŒëŸ¬ë¦¬
- **OpenCV**: ì»´í“¨í„° ë¹„ì „ (`cv2`)
- **PCL-Python**: í¬ì¸íŠ¸ í´ë¼ìš°ë“œ ì²˜ë¦¬
- **Matplotlib**: ë°ì´í„° ì‹œê°í™”
- **SciPy**: ê³¼í•™ ê³„ì‚°

### ììœ¨ì£¼í–‰ íŠ¹í™” í™œìš©
- ì¹¼ë§Œ í•„í„° êµ¬í˜„
- SLAM ì•Œê³ ë¦¬ì¦˜
- ê²½ë¡œ ê³„íš (Path Planning)
- ì„¼ì„œ í“¨ì „ (Sensor Fusion)

---

## ğŸ¯ ë§ˆë¬´ë¦¬

ì´ ê°€ì´ë“œë¥¼ í†µí•´ NumPyë¥¼ ììœ¨ì£¼í–‰ ê°œë°œì— íš¨ê³¼ì ìœ¼ë¡œ í™œìš©í•˜ëŠ” ë°©ë²•ì„ ìµí˜”ìŠµë‹ˆë‹¤. 

### ë‹¤ìŒ ë‹¨ê³„
1. **ì‹¤ì œ ì„¼ì„œ ë°ì´í„°**ë¡œ ì—°ìŠµí•´ë³´ê¸°
2. **OpenCVì™€ ê²°í•©**í•˜ì—¬ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¬í™”
3. **ROS(Robot Operating System)**ì™€ í†µí•©
4. **ì‹¤ì‹œê°„ ì²˜ë¦¬** ìµœì í™” ê¸°ë²• í•™ìŠµ

---

